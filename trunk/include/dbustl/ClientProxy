#ifndef DBUSTL_CLIENTPROXY
#define DBUSTL_CLIENTPROXY

#include <dbus/dbus.h>

#include <string>
#include <sstream>

#include <dbustl/DBusException>
#include <dbustl/TypesConvertion>
#include <dbustl/Message>

namespace dbustl {

    class Connection;

    class ClientProxy {
        public:
            // Path the object path we target
            // destination is only required if this connection talks to a message bus
            // In this case it must contain the name of the connection this message is intended for,
            // otherwise givin the connection object is enough
            ClientProxy(Connection* conn, const std::string& path, const std::string& destination = "");

            // For synchronous blocking calls, set the timeout to val.
            // -1 means default value
            void setTimeout(int timeout) { _timeout = timeout; };
            // Sets the interface to use for the remote object.
            // If empty(the default), the default interface is used
            void setInterface(const std::string& interface) { _interface = interface; };

        #ifndef DBUSTL_NO_EXCEPTIONS
            //Returns the last error that happened
            const DBusException& error();
        #endif

            //If fails returns false and error contains the detailed error value
            template<typename... Args>
            bool call(const std::string& methodName, const Args&... args);
            
            Message createMethodCall(const std::string& methodName) const;
            Message call(Message& method_call);

            //Helper class 
            class Interface {
            public:    
                Interface(std::string name) : _name(name) {};
                const std::string& name() const { return _name; };
            private:
                std::string _name;
            };

        private:
            //Disallow the following constructs
            ClientProxy(const ClientProxy& con);
            ClientProxy& operator=(ClientProxy&);
            
        #ifdef DBUSTL_NO_EXCEPTIONS
            inline void throw_or_set(const DBusException& error) {_error = error; };
            inline void throw_or_set(const chat *name, const char *message) {_error = DBusException(name, message); };
        #else
            static inline void throw_or_set(const DBusException& error) {throw error; };
            static inline void throw_or_set(const char *name, const char *message) { throw DBusException(name, message); };
        #endif
            
            //This method processes input arguments of the form const T&
            template<typename T, typename... Args>            
            void processInArgs(Message& method_call, const T& invalue, const Args&... args);

            //This method processes input arguments of the form const T*
            template<typename T, typename... Args>            
            void processInArgs(Message& method_call, const T* invalue, const Args&... args);

            //This method processes Interface input argument
            template<typename... Args>            
            void processInArgs(Message& method_call, const Interface& intf, const Args&... args);

            //This method gets called when all arguments are processed
            template<typename T, typename... Args>            
            void processInArgs(Message& msg, T* outvalue, const Args&... args);

            void processInArgs(Message& msg);

            //This method processes output arguments of the form T*
            template<typename T, typename... Args>            
            void processOutArgs(Message& method_call, T* outvalue, const Args&... args);

            void processOutArgs(Message& method_call);
            
            Connection *_conn;
            std::string _path;
            std::string _destination;
            std::string _interface;
            int _timeout; //call timeout in milliseconds, -1 means default
            DBusException _error;
    };


    template<typename... Args>
    bool ClientProxy::call(const std::string& methodName, const Args&... args)
    {
        Message method_call(createMethodCall(methodName));
        
        if(!method_call.dbus()) {
            throw_or_set(DBUS_ERROR_NO_MEMORY, "Not enough memory to allocate DBUS message");
        }
        
        _error = DBusException();
        processInArgs(method_call, args...);
        return !_error.isSet();
    }

    template<typename T, typename... Args>            
    void ClientProxy::processInArgs(Message& method_call, const T& invalue, const Args&... args)
    {
        method_call << invalue;
        processInArgs(method_call, args...);
    }

    template<typename T, typename... Args>            
    void ClientProxy::processInArgs(Message& method_call, const T* invalue, const Args&... args)
    {
        method_call << invalue;
        processInArgs(method_call, args...);
    }

    template<typename T, typename... Args>            
    void ClientProxy::processInArgs(Message& msg, T* outvalue, const Args&... args)
    {
        //All input arguments are consumed, process call now...
        processInArgs(msg);
        if(!_error.isSet()) {
            processOutArgs(msg, outvalue, args...);
        }
    }

    template<typename... Args>            
    void ClientProxy::processInArgs(Message& method_call, const Interface& intf, const Args&... args)
    {
        dbus_message_set_interface(method_call.dbus(), intf.name().c_str());
        processInArgs(method_call, args...);
    }

    template<typename T, typename... Args>            
    void ClientProxy::processOutArgs(Message& method_reply, T* outvalue, const Args&... args)
    {
        method_reply >> outvalue;
        if(method_reply.isValid()) {
            processOutArgs(method_reply, args...);
        }
        else {
            std::stringstream ss;
            ss << "Unable to deserialize return parameter at index " << method_reply.parsedArguments() - 1;
            throw_or_set("TBD", ss.str().c_str());
        }
    }

}

#endif /* DBUSTL_CLIENTPROXY */

