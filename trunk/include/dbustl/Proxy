#ifndef DBUSTL_PROXY
#define DBUSTL_PROXY

#include <dbus/dbus.h>

#include <string>

#include <dbustl/DBusException>
#include <dbustl/TypesConvertion>

namespace dbustl {

    class Connection;

    class Proxy {
        public:
            // Path the object path we target
            // destination is only required if this connection talks to a message bus
            // In this case it must contain the name of the connection this message is intended for,
            // otherwise givin the connection object is enough
            Proxy(Connection* conn, const std::string& path, const std::string& destination = "");

            // For synchronous blocking calls, set the timeout to val.
            // -1 means default value
            void setTimeout(int timeout) { _timeout = timeout; };
            // Sets the interface to use for the remote object.
            // If empty(the default), the default interface is used
            void setInterface(const std::string& interface) { _interface = interface; };

        #ifndef DBUSTL_NO_EXCEPTIONS
            //Returns the last error that happened
            const DBusException& error();
        #endif

            //If fails returns false and error contains the detailed error value
            template<typename... Args>
            bool call(const std::string& methodName, const Args&... args);
            
        private:
            //Disallow the following constructs
            Proxy(const Proxy& con);
            Proxy& operator=(Proxy&);
            
        #ifdef DBUSTL_NO_EXCEPTIONS
            inline void throw_or_set(const DBusException& error) {_error = error; };
            inline void throw_or_set(const chat *name, const char *message) {_error = DBusException(name, message); };
        #else
            static inline void throw_or_set(const DBusException& error) {throw error; };
            static inline void throw_or_set(const char *name, const char *message) { throw DBusException(name, message); };
        #endif
            
            DBusMessage* newMethodCall(const std::string& methodName);

            template<typename T, typename... Args>            
            inline bool processCall(DBusMessage *method_call, DBusMessageIter *it, const T& invalue, const Args&... args);

            template<typename T, typename... Args>            
            inline bool processCall(DBusMessage *method_call, DBusMessageIter *it, const T* invalue, const Args&... args);

            template<typename T, typename... Args>            
            inline bool processCall(DBusMessage *method_call, DBusMessageIter *it, T* outvalue, const Args&... args);

            bool processCall(DBusMessage *method_call, DBusMessageIter *);
      
            DBusMessage* doBlockingCall(DBusMessage *method_call);
      
            Connection *_conn;
            std::string _path;
            std::string _destination;
            std::string _interface;
            int _timeout; //call timeout in milliseconds, -1 means default
        #ifdef DBUSTL_NO_EXCEPTIONS
            DBusException _error;
        #endif
            bool _parsingInputArguments;

            //Utility class: Handles DBusMessage refcounting automagically
            class MessageContainer {
                public:
                    MessageContainer() { _msg = NULL; };

                    MessageContainer(DBusMessage *msg) {_msg = msg; };

                    MessageContainer(const MessageContainer& other) {
                        if(other._msg) dbus_message_ref(other._msg);
                        _msg = other._msg;
                    };

                    ~MessageContainer() { if(_msg) dbus_message_unref(_msg); };

                    MessageContainer& operator=(MessageContainer& other) {
                        if(other._msg) dbus_message_ref(other._msg);
                        if(_msg) dbus_message_unref(_msg);
                        _msg = other._msg;
                        return *this;
                    };
                    
                    MessageContainer& operator=(DBusMessage *msg) {
                        if(_msg) dbus_message_unref(_msg);
                        _msg = msg;
                        return *this;
                    };
                    
                    DBusMessage* dbus() { return _msg; };
                    
                private:
                    DBusMessage *_msg;
            };
    };


    template<typename... Args>
    bool Proxy::call(const std::string& methodName, const Args&... args)
    {
        DBusMessageIter append_iterator;
        MessageContainer method_call(newMethodCall(methodName));
        
        if(!method_call.dbus()) {
            throw_or_set(DBUS_ERROR_NO_MEMORY, "Not enough memory to allocate DBUS message");
        }
        
        dbus_message_iter_init_append(method_call.dbus(), &append_iterator);
        
        _parsingInputArguments = true;
        return processCall(method_call.dbus(), &append_iterator, args...);
    }

    template<typename T, typename... Args>            
    bool Proxy::processCall(DBusMessage *method_call, DBusMessageIter *it, const T& invalue, const Args&... args)
    {
        if(!_parsingInputArguments) {
          //Should definately not be here
          throw_or_set(DBUS_ERROR_NO_MEMORY, "Issue with arguments ordering");
          return false;
        }
        if(serialize(it, invalue) == TRUE) {
            return processCall(method_call, it, args...);
        }
        else {
            return false;
        }
    }

    template<typename T, typename... Args>            
    bool Proxy::processCall(DBusMessage *method_call, DBusMessageIter *it, const T* invalue, const Args&... args)
    {
        if(!_parsingInputArguments) {
          //Should definately not be here
          throw_or_set(DBUS_ERROR_NO_MEMORY, "Issue with arguments ordering");
          return false;
        }
        if(serialize(it, invalue) == TRUE) {
            return processCall(method_call, it, args...);
        }
        else {
            return false;
        }
    }

    template<typename T, typename... Args>            
    bool Proxy::processCall(DBusMessage *msg, DBusMessageIter *it, T* outvalue, const Args&... args)
    {
        MessageContainer reply;
        if(_parsingInputArguments) {
            _parsingInputArguments = false;
            reply = doBlockingCall(msg);
            if(reply.dbus()) {
                //Overwrite message and iterator
                msg = reply.dbus();
                dbus_message_iter_init(msg, it);
            }
            else {
                return false;
            }
        }
        
        if(deserialize(it, outvalue) == TRUE) {
            dbus_message_iter_next(it);
            return processCall(msg, it, args...);
        }
        else {
            return false;
        }
    }
}

#endif /* DBUSTL_PROXY */

