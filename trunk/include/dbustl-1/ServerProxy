/*
 *  DBUSTL - DBus Template Library
 *
 *  Copyright (C) 2008  Fabien Chevalier <fabchevalier@free.fr>
 *  
 *
 *  This file is part of the DBus Template Library.
 *
 *  The DBus Template Library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  DBus Template Library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with DBus Template Library.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef DBUSTL_SERVERPROXY
#define DBUSTL_SERVERPROXY

#include <dbus/dbus.h>

#include <string>
#include <sstream>
#include <functional>
#include <map>

#include <dbustl-1/Config>
#include <dbustl-1/DBusException>
#include <dbustl-1/TypesConvertion>
#include <dbustl-1/Message>

namespace dbustl {

    class Connection;

    class ServerProxy {
        public:
            // Path the object path we target
            // destination is only required if this connection talks to a message bus
            // In this case it must contain the name of the connection this message is intended for,
            // otherwise giving the object path is enough
            ServerProxy(Connection* conn, const std::string& path, const std::string& destination = "");
            ~ServerProxy();

            // For synchronous blocking calls, set the timeout in milliseconds.
            // -1 means default value
            void setTimeout(int timeout) { _timeout = timeout; };
            // Sets the interface to use for the remote object.
            // If empty(the default), the default interface is used
            void setInterface(const std::string& interface) { _interface = interface; };

        #ifndef DBUSTL_NO_EXCEPTIONS
            //Returns the last error that happened
            const DBusException& error();
        #endif

            //Synchronous call
            //If fails returns false and error contains the detailed error value
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename... Args>
            bool call(const std::string& methodName, const Args&... args);
        #endif
            //Synchronous call : legacy C++ syntax
            Message createMethodCall(const std::string& methodName) const;
            Message call(Message& method_call);
            
            //Asynchronous call : functor version            
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename MethodCallback, typename... Args>
            bool asyncCall(const std::string& methodName, const MethodCallback& callback, const Args&... args);
        #endif
            
            //Asynchronous call : pointer to function version
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename... Args>
            inline bool asyncCall(const std::string& methodName, void (*callback)(Message&, const DBusException&), const Args&... args);
        #endif
            
            //Asynchronous call : pointer to member version
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename _Class, typename... Args>
            inline bool asyncCall(const std::string& methodName, void (_Class::*callback)(Message&, const DBusException&), _Class *c, const Args&... args);
        #endif
            
            template<typename MethodCallback>
            void asyncCall(Message& method_call, const MethodCallback& callback);

            //Asynchronous call, legacy C++ syntax: pointer to function version
            inline void asyncCall(Message& method_call, void (*callback)(Message&, const DBusException&));

            //Signals Handling : functor version
            template<typename SignalHandler>
            bool setSignalHandler(const std::string& signalName, const SignalHandler& handler);

            //Signals Handling : pointer to function version
            inline bool setSignalHandler(const std::string& signalName, void (*handler)(Message& signal));

            //Signals Handling : pointer to member version
            template<typename _Class>
            inline bool setSignalHandler(const std::string& signalName, void (_Class::*handler)(Message signal), _Class *c);

            //Removes one of the handler set by one of the calls above
            bool removeSignalHandler(const std::string& signalName);

            /**
             * This class is used in call() member of ServerProxy class to use
             * an alternative Interface name for that particular method call only.
             */
            class Interface {
            public:    
                /**
                 * Public constructor.
                 * @name the interface to call method on.
                 */
                Interface(std::string name) : _name(name) {};
                /**
                 * Public accessor.
                 * @returns the interface name.
                 */
                const std::string& name() const { return _name; };
            private:
                std::string _name;
            };

        private:
            //Disallow the following constructs
            ServerProxy(const ServerProxy& con);
            ServerProxy& operator=(ServerProxy&);
            
        #ifdef DBUSTL_NO_EXCEPTIONS
            inline void throw_or_set(const DBusException& error) {_error = error; };
            inline void throw_or_set(const chat *name, const char *message) {_error = DBusException(name, message); };
        #else
            static inline void throw_or_set(const DBusException& error) {throw error; };
            static inline void throw_or_set(const char *name, const char *message) { throw DBusException(name, message); };
        #endif
            
            /////////////////////////////////
            // Synchronous calls templates //
            /////////////////////////////////
            
            //This method processes input arguments of the form const T&
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename T, typename... Args>            
            void processInArgs(Message& method_call, const T& invalue, const Args&... args);
        #endif

            //This method processes input arguments of the form const T*
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename T, typename... Args>            
            void processInArgs(Message& method_call, const T* invalue, const Args&... args);
        #endif

            //This method processes Interface input argument
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename... Args>            
            void processInArgs(Message& method_call, const Interface& intf, const Args&... args);
        #endif

            //This method gets called when all arguments are processed
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename T, typename... Args>            
            void processInArgs(Message& msg, T* outvalue, const Args&... args);
        #endif

            void processInArgs(Message& msg);

            //This method processes output arguments of the form T*
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename T, typename... Args>            
            void processOutArgs(Message& method_call, T* outvalue, const Args&... args);
        #endif

            void processOutArgs(Message& method_call);
            
            //////////////////////////////////
            // Asynchronous calls templates //
            //////////////////////////////////
            
            //This method processes input arguments of the form const T&
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename T, typename MethodCallback, typename... Args>            
            void processAsyncInArgs(Message& method_call, const MethodCallback& callback, const T& invalue, const Args&... args);
        #endif

            //This method processes input arguments of the form const T*
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename T, typename MethodCallback, typename... Args>            
            void processAsyncInArgs(Message& method_call, const MethodCallback& callback, const T* invalue, const Args&... args);
        #endif

            //This method processes Interface input argument
        #ifdef DBUSTL_VARIADIC_TEMPLATES
            template<typename MethodCallback, typename... Args>            
            void processAsyncInArgs(Message& method_call, const MethodCallback& callback, const Interface& intf, const Args&... args);
        #endif

            template<typename MethodCallback>            
            void processAsyncInArgs(Message& msg, const MethodCallback& callback);

            //static methods for asynchronous calls handling
            template<typename MethodCallback>            
            static void methodCallbackDelete(void *object);

            template<typename MethodCallback>            
            static void callCompleted(DBusPendingCall *pending, void *user_data);

            //static methods for signals handling
            static DBusHandlerResult signalsProcessingMethod(DBusConnection *connection, 
                DBusMessage *dbusMessage, void *user_data);

            template<typename SignalHandler>            
            static void signalHandlerCallback(void *functor, Message& signal);

            template<typename SignalHandler>            
            static void signalHandlerDelete(void *functor);

            //Helper methods for signals processing
            bool setWatchSignal(const std::string& signalName, bool enable);

            Connection *_conn;
            std::string _path;
            std::string _destination;
            //Interface used by default for outgoing calls
            std::string _interface;
            //call timeout in milliseconds, -1 means default
            int _timeout; 
            DBusException _error;
            
            struct FunctorWrapper {
                typedef void (*call_functor_t)(void *functor, Message& signal);
                typedef void (*delete_functor_t)(void *functor);
                
                FunctorWrapper() {};
                
                FunctorWrapper(void* lfunctor, call_functor_t lcall_functor, delete_functor_t ldelete_functor)
                 : functor(lfunctor), call_functor(lcall_functor), delete_functor(ldelete_functor)
                {
                }
                
                void *functor;
                call_functor_t call_functor;
                delete_functor_t delete_functor;
            };                
            //Signals callbacks, per signal
            std::map<std::string, FunctorWrapper> _signalsHandlers;    
            
            static DBusObjectPathVTable _vtable;
    };

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename... Args>
    bool ServerProxy::call(const std::string& methodName, const Args&... args)
    {
        Message method_call(createMethodCall(methodName));
        
        if(!method_call.dbus()) {
            throw_or_set(DBUS_ERROR_NO_MEMORY, "Not enough memory to allocate DBUS message");
            return false;
        }
        
        _error = DBusException();
        processInArgs(method_call, args...);
        return !_error.isSet();
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename T, typename... Args>            
    void ServerProxy::processInArgs(Message& method_call, const T& invalue, const Args&... args)
    {
        method_call << invalue;
        processInArgs(method_call, args...);
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename T, typename... Args>            
    void ServerProxy::processInArgs(Message& method_call, const T* invalue, const Args&... args)
    {
        method_call << invalue;
        processInArgs(method_call, args...);
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename T, typename... Args>            
    void ServerProxy::processInArgs(Message& msg, T* outvalue, const Args&... args)
    {
        //All input arguments are consumed, process call now...
        processInArgs(msg);
        if(!_error.isSet()) {
            processOutArgs(msg, outvalue, args...);
        }
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename... Args>            
    void ServerProxy::processInArgs(Message& method_call, const Interface& intf, const Args&... args)
    {
        dbus_message_set_interface(method_call.dbus(), intf.name().c_str());
        processInArgs(method_call, args...);
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename T, typename... Args>            
    void ServerProxy::processOutArgs(Message& method_reply, T* outvalue, const Args&... args)
    {
        method_reply >> outvalue;
        if(method_reply.isValid()) {
            processOutArgs(method_reply, args...);
        }
        else {
            std::stringstream ss;
            ss << "Unable to deserialize return parameter at index " << method_reply.parsedArguments() - 1;
            throw_or_set("org.dbustl.ReturnParameterError", ss.str().c_str());
        }
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename MethodCallback, typename... Args>
    bool ServerProxy::asyncCall(const std::string& methodName, const MethodCallback& callback, const Args&... args)
    {
        Message method_call(createMethodCall(methodName));
        
        if(!method_call.dbus()) {
            throw_or_set(DBUS_ERROR_NO_MEMORY, "Not enough memory to allocate DBUS message");
            return false;
        }
        
        _error = DBusException();
        processAsyncInArgs(method_call, callback, args...);
        return !_error.isSet();
    }
#endif
    
#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename... Args>
    bool ServerProxy::asyncCall(const std::string& methodName, void (*callback)(Message&, const DBusException&), const Args&... args)
    {
        return asyncCall(methodName, std::ptr_fun(callback), args...);
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename _Class, typename... Args>
    bool ServerProxy::asyncCall(const std::string& methodName, void (_Class::*callback)(Message&, const DBusException&), _Class *c, const Args&... args)
    {
        return asyncCall(methodName, std::bind(callback, c, std::placeholders::_1, std::placeholders::_2), args...);
    }
#endif

    template<typename MethodCallback>            
    void ServerProxy::asyncCall(Message& method_call, const MethodCallback& callback)
    {
        DBusPendingCall *pending_return;
	
        if(dbus_connection_send_with_reply(_conn->dbus(), method_call.dbus(), &pending_return, _timeout) == FALSE) {
            throw_or_set(DBUS_ERROR_NO_MEMORY, "Not enough memory to send DBUS message");
            return;
        }
    
        if(pending_return) {
            if(dbus_pending_call_set_notify(pending_return, callCompleted<MethodCallback>, 
                  new MethodCallback(callback), methodCallbackDelete<MethodCallback>) == FALSE) {
                throw_or_set(DBUS_ERROR_NO_MEMORY, "Not enough memory to set callback for DBUS message");
            }
        }
        else {
            throw_or_set("TBD", "Disconnected");
        }
    }

    void ServerProxy::asyncCall(Message& method_call, void (*callback)(Message&, const DBusException&))
    {
        asyncCall(method_call, std::ptr_fun(callback));
    }

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename T, typename MethodCallback, typename... Args>            
    void ServerProxy::processAsyncInArgs(Message& method_call, const MethodCallback& callback, const T& invalue, const Args&... args)
    {
        method_call << invalue;
        processAsyncInArgs(method_call, callback, args...);
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename T, typename MethodCallback, typename... Args>            
    void ServerProxy::processAsyncInArgs(Message& method_call, const MethodCallback& callback, const T* invalue, const Args&... args)
    {
        method_call << invalue;
        processAsyncInArgs(method_call, callback, args...);
    }
#endif

#ifdef DBUSTL_VARIADIC_TEMPLATES
    template<typename MethodCallback, typename... Args>            
    void ServerProxy::processAsyncInArgs(Message& method_call, const MethodCallback& callback, const Interface& intf, const Args&... args)
    {
        dbus_message_set_interface(method_call.dbus(), intf.name().c_str());
        processAsyncInArgs(method_call, callback, args...);
    }
#endif

    template<typename MethodCallback>            
    void ServerProxy::processAsyncInArgs(Message& msg, const MethodCallback& callback)
    {
        if(msg.isValid()) {
            asyncCall(msg, callback);
        }
    }

    template<typename MethodCallback>            
    void ServerProxy::methodCallbackDelete(void *object)
    {
        MethodCallback *cb = static_cast<MethodCallback*>(object);
        delete cb;
    }

    template<typename MethodCallback>            
    void ServerProxy::callCompleted(DBusPendingCall *pending, void *user_data)
    {
        DBusException e;
        MethodCallback *callback = static_cast<MethodCallback*>(user_data);
    
        Message reply(dbus_pending_call_steal_reply(pending));
     
        dbus_set_error_from_message(e.dbus(), reply.dbus());

        //call user function
        (*callback)(reply, e);

        dbus_pending_call_unref(pending);
    }
    
    bool ServerProxy::setSignalHandler(const std::string& signalName, void (*handler)(Message& signal))
    {
        return setSignalHandler(signalName, std::ptr_fun(handler));
    }

    template<typename _Class>
    bool ServerProxy::setSignalHandler(const std::string& signalName, void (_Class::*handler)(Message signal), _Class *c)
    {
        return setSignalHandler(signalName, std::bind1st(std::mem_fun(handler), c));
    }

    template<typename SignalHandler>
    bool ServerProxy::setSignalHandler(const std::string& signalName, const SignalHandler& handler)
    {
        if(!_signalsHandlers.count(signalName)) {
            if(!setWatchSignal(signalName, true)) {
                return false;
            }
            
            _signalsHandlers[signalName] = FunctorWrapper(new SignalHandler(handler),
                                                        signalHandlerCallback<SignalHandler>,
                                                        signalHandlerDelete<SignalHandler>);
        }
        else {
            _signalsHandlers[signalName] = FunctorWrapper(new SignalHandler(handler),
                                                        signalHandlerCallback<SignalHandler>,
                                                        signalHandlerDelete<SignalHandler>);
        }
        return true;
    }

    template<typename SignalHandler>            
    void ServerProxy::signalHandlerCallback(void *functor, Message& signal)
    {
        SignalHandler *sh = static_cast<SignalHandler *>(functor);
        (*sh)(signal);
    }

    template<typename SignalHandler>            
    void ServerProxy::signalHandlerDelete(void *functor)
    {
        SignalHandler *sh = static_cast<SignalHandler *>(functor);
        delete sh;
    }
}

#endif /* DBUSTL_SERVERPROXY */

