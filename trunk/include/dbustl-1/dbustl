/*
 *  DBUSTL - DBus Template Library
 *
 *  Copyright (C) 2008  Fabien Chevalier <fabchevalier@free.fr>
 *  
 *
 *  This file is part of the DBus Template Library.
 *
 *  The DBus Template Library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  DBus Template Library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with DBus Template Library.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/** @mainpage
 *
 * DBUSTL is an easy do to use, extensible C++ wrapper for DBus that 
 * makes the use of DBuswith plain C++ possible.<br/>
 * 
 * <strong>Important note:</strong> To be used with the most elegant
 * syntax, DBUSTL requires cutting edge C++ features, that are currently
 *  only available with gcc 4.3 and upper. Use of older versions of gcc
 *  is possible, but will make the syntax a little more convoluted.<br/>
 * 
 *  - @ref intro
 *  - @ref advanced_features
 *  - @ref compat_syntax
 *  - @ref design
 *  - @ref extending
 *  - @ref todo
 */

/** 
 * @page intro The 5 minutes introduction
 * 
 * This pages gets you up and running with a DBUSTL installation
 * and shows you how to build a simple program.
 * 
 * @section requirements Build requirements
 * 
 * To build DBUSTL the following dependancies are requires:
 *   - gcc: >= 4.3
 *   - DBus development libraries (>= 1.2): older versions may work
 * but haven't been tested
 *   - glib: tested on 2.16, olders versions might work too
 *   - dbus-glib: tested on 0.76, olders versions might work too
 *   - python-dbus: tested with 0.82.4
 * 
 * It is still possible to use DBUSTL with an older compiler: refer to
 * @ref compat_syntax for more information.
 * 
 * glib and dbus-glib are only required if you intend to receive DBUS signals
 * from remote objects.
 * 
 * python-dbus is only required if you intend to run the examples provided with
 * this introduction.
 * 
 * @section build Building
 * 
 * That is as simple as running
 * @code
 * $tar -zxvf dbustl-x.y.tar.bz2
 * $cd dbustl-x.y
 * $./configure
 * $make
 * $su
 * #make install
 * #exit
 * @endcode
 * 
 * Now DBUSTL should be installed in /usr/local
 * 
 * @section hello_world Hello world, revisited
 * 
 * I couldn't resist the temptation to introduce you with a so-called
 * 'Hello, World' dbus example.
 * 
 * So let's try to compile the simplest.cpp program:
 * @include simplest.cpp
 * 
 * This program is the simplest program that can be imagined.
 * First is the creation of a proxy, that will (as its name sugggests)
 * proxy the calls on the underlying exposed DBUS object.
 * Here we create a proxy on the /PythonServerObject exposed by the
 * com.example.SampleService on the session bus.
 * But the most important line of the program is the call to:
 * @code
 * remoteObject.call("SimpleHello", "Hello world", &reply); 
 * @endcode
 * 
 * This single line tells DBUSTL to:
 *   -# Create a method call message for "SimpleHello" method
 *   -# Converts the "Hello World" to a DBUS string
 *   -# Send the message on the connection and receive the reply
 *   -# Convert the DBUS string in the reply back to a std::string object.
 * 
 * But enough talking, let's try it out: here is the line required to build it by hand with gcc.
 * @code
 * $g++ -std=c++0x -Wall simplest.cpp `pkg-config --cflags --libs dbustl-1` -o simplest
 * @endcode
 * 
 * <strong>Note:</strong> the curious reader will have noticed the apparition of a somewhat
 * unusual compiler option. The -std=c++0x option tells gcc to turn on the support for the
 * still to be finalized C++ standard called C++0x, that is required for optimal
 * DBUSTL operation.
 * 
 * To run the test, launch the test-service.py that is found in the tests/ directory.
 * Then we can start our simplest hello world:
 * @code
 * $./simplest
 * Hello world
 * $
 * @endcode
 *
 * If something bad happens (such as if you forgot to launch test-service.py), then an exception
 * is thrown:
 * @code
 * $./simplest 
 * org.freedesktop.DBus.Error.ServiceUnknown: The name com.example.SampleService was not provided by any .service files
 * $
 * @endcode
 */

/** 
 * @page advanced_features Advanced features
 * 
 * @section datatypes More complex datatypes
 * @section async Asynchronous method calls
 * @section signals Working with signals.
 * 
 */

/** 
 * @page compat_syntax Compatibility syntax
 * 
 * Compatibility syntax is there to allow you to use DBUSTL even
 * if you don't have a C++ compiler that support variadic templates.
 * 
 * The main inconvenient of this alternative approach is that it makes
 * the code a bit more verbose, and far less 'magical':
 * 
 * @include compat.cpp
 * 
 * As you can see this is a bit more complicated that the equivalent
 * code for our @ref hello_world "variadic templates enabled hello world" example.
 * The main issue is the serialization and deserialization of the parameters
 * that are handled should behind the scene, but that have to be exposed
 * here.
 * 
 */

/** 
 * @page design Design paradigms
 * 
 * TODO: explain here why DBUSTL is as it is today
 * 
 */

/** 
 * @page extending Extending DBUSTL to support custom data types
 * 
 * @section Custom structs
 * 
 * @section Custom containers
 */

/** 
 * @page todo Future improvements
 * 
 * - Implement exceptions less support
 * - Get rid of dbus-glib dependancy, by really implementing GlibEventLoop
 */

#include <dbustl-1/Message>
#include <dbustl-1/Connection>
#include <dbustl-1/ServerProxy>
#include <dbustl-1/types/vector>
#include <dbustl-1/types/list>
#include <dbustl-1/types/set>
#include <dbustl-1/types/map>

