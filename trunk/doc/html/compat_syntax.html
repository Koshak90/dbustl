<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DBus Template Library: Compatibility syntax</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="compat_syntax">Compatibility syntax </a></h1>Compatibility syntax is there to allow you to use DBUSTL even if you don't have a C++ compiler that support variadic templates.<p>
The main inconvenient of this alternative approach is that it makes the code a bit more verbose, and far less 'magical':<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;<a class="code" href="dbustl.html">dbustl-1/dbustl</a>&gt;</span>

<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>dbustl;
 
<span class="keywordtype">int</span> main()
{
    ServerProxy remoteObject(Connection::sessionBus(), 
        <span class="stringliteral">"/PythonServerObject"</span>, <span class="stringliteral">"com.example.SampleService"</span>);
    <span class="keywordflow">try</span> {
        Message methodMsg(NULL), replyMsg(NULL);
        <span class="keywordtype">string</span> reply;
        
        <span class="comment">/* Here we create the method call message, and adds all the </span>
<span class="comment">         * parametersusing the &lt;&lt; operator </span>
<span class="comment">         */</span>
        methodMsg = remoteObject.createMethodCall(<span class="stringliteral">"SimpleHello"</span>);
        methodMsg &lt;&lt; <span class="stringliteral">"Hello world"</span>;
        <span class="comment">/* We then send the method call message and wait for the reply */</span>
        replyMsg = remoteObject.call(methodMsg); 
        <span class="comment">/* Deserialization of the arguments in the reply message */</span>
        replyMsg &gt;&gt; reply;
        <span class="comment">/* isValid() checks that reading reply message parameters suceeded */</span>
        <span class="keywordflow">if</span>(replyMsg.isValid()) {
            <span class="comment">/* reply now contains a valid string */</span>
            cout &lt;&lt; reply &lt;&lt; endl;
        }
    }
    <span class="keywordflow">catch</span>(<span class="keyword">const</span> DBusException&amp; e) {
        <span class="comment">/* Dbus call failed: e.name() constains error cause */</span>
        cerr &lt;&lt; e.what() &lt;&lt; endl;
    } 
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
As you can see this is a bit more complicated that the equivalent code for our <a class="el" href="intro.html#hello_world">variadic templates enabled hello world</a> example. The main issue is the serialization and deserialization of the parameters that are handled should behind the scene, but that have to be exposed here. </div>
<hr size="1"><address style="text-align: right;"><small>DBus Template Library 0.2.0 documentation, generated by &nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
