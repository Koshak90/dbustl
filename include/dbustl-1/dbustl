/*
 *  DBUSTL - DBus Template Library
 *
 *  Copyright (C) 2008  Fabien Chevalier <fabchevalier@free.fr>
 *  
 *
 *  This file is part of the DBus Template Library.
 *
 *  The DBus Template Library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  DBus Template Library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with DBus Template Library.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/** 
 * @mainpage
 *
 * DBUSTL is an easy do to use, extensible C++ wrapper for DBus that 
 * makes the use of DBus with plain C++ possible.<br></br>
 * 
 * <strong>Important note:</strong> To be used with the most elegant
 * syntax, DBUSTL requires a cutting edge C++ feature, that is currently
 * only available with gcc 4.3 and upper. Use of older versions of gcc
 * is possible, but will make the syntax a little more convoluted.
 * 
 *  - @ref intro
 *  - @ref advanced_features
 *  - @ref compat_syntax
 *  - @ref design
 *  - @ref extending
 *  - @ref todo
 */

/** 
 * @page intro The 5 minutes introduction
 * 
 * This pages gets you up and running with a DBUSTL installation
 * and shows you how to build a simple program.
 * 
 * @section requirements Build requirements
 * 
 * To build DBUSTL the following dependancies are requires:
 *   - gcc: >= 4.3
 *   - DBus development libraries (>= 1.2): older versions may work
 * but haven't been tested
 *   - glib: tested on 2.16, olders versions might work too
 *   - dbus-glib: tested on 0.76, olders versions might work too
 *   - python-dbus: tested with 0.82.4
 * 
 * It is still possible to use DBUSTL with an older compiler: refer to
 * @ref compat_syntax for more information.
 * 
 * glib and dbus-glib are only required if you intend to receive DBUS signals
 * from remote objects.
 * 
 * python-dbus is only required if you intend to run the examples provided with
 * this introduction.
 * 
 * @section build Building
 * 
 * That is as simple as running
 * @code
 * $tar -zxvf dbustl-x.y.tar.bz2
 * $cd dbustl-x.y
 * $./configure
 * $make
 * $su
 * #make install
 * #exit
 * @endcode
 * 
 * Now DBUSTL should be installed in /usr/local
 * 
 * @section hello_world Hello world, revisited
 * 
 * I couldn't resist the temptation to introduce you with a so-called
 * 'Hello, World' dbus example.
 * 
 * So let's try to compile the simplest.cpp program:
 * @include simplest.cpp
 * 
 * This program is the simplest program that can be imagined.
 * First is the creation of a proxy, that will (as its name sugggests)
 * proxy the calls on the underlying exposed DBUS object.
 * Here we create a proxy on the /PythonServerObject exposed by the
 * com.example.SampleService on the session bus.
 * But the most important line of the program is the call to:
 * @code
 * remoteObject.call("SimpleHello", "Hello world", &reply); 
 * @endcode
 * 
 * This single line tells DBUSTL to:
 *   -# Create a method call message for "SimpleHello" method
 *   -# Converts the "Hello World" to a DBUS string
 *   -# Send the message on the connection and receive the reply
 *   -# Convert the DBUS string in the reply back to a std::string object.
 * 
 * But enough talking, let's try it out: here is the line required to build it by hand with gcc.
 * @code
 * $g++ -std=c++0x -Wall simplest.cpp `pkg-config --cflags --libs dbustl-1` -o simplest
 * @endcode
 * 
 * <strong>Note:</strong> the curious reader will have noticed the apparition of a somewhat
 * unusual compiler option. The -std=c++0x option tells gcc to turn on the support for the
 * still to be finalized C++ standard called C++0x, that is required for optimal
 * DBUSTL operation.
 * 
 * To run the test, launch the test-service.py that is found in the tests/ directory.
 * Then we can start our simplest hello world:
 * @code
 * $./simplest
 * Hello world
 * $
 * @endcode
 *
 * If something bad happens (such as if you forgot to launch test-service.py), then an exception
 * is thrown:
 * @code
 * $./simplest 
 * org.freedesktop.DBus.Error.ServiceUnknown: The name com.example.SampleService was not provided by any .service files
 * $
 * @endcode
 * 
 * @section explanations Some explanations
 *
 * @subsection parameters Parameters passing
 * 
 * By now you may be wondering: how the hell does DBUSTL make the difference
 * between input and output parameters ?
 * The answer is quite simple: input parameters start after the first one, which
 * is always the DBus method name, until a pointer is found. Attempts to mix
 * pointers with non pointers will result in failure at compile time.
 * This means all the method calls having a similar looks and feel:
 * @code 
 * proxy.call("MyMethod", inparam1, inparam2, ..., inparamN, &outparam1, &outparam2, ..., &outparamY)
 * @endcode
 * 
 * @note There is no hard limit on the number of input/output parameters
 * that can be passed.
 * @note As an exception to the rule above, special support is provided for C strings, which means
 * that the following code will work too:
 * @code 
 * proxy.call("MyMethod", inparam1,... , "a C string as input parameter",..., inparam2, ..., inparamN, &outparam1, ...)
 * @endcode
 * 
 * @subsection interface_choosing Choosing the right interface
 * The DBus specification allows to target messages calls to a specific object's interface. Specifying
 * the interface is optionnal from the DBus protocol perspective, so it is for DBUSTL.
 * 
 * Here is how we can do that with DBUSTL:
 * @subsubsection interface_setinterface ServerProxy::setInterface() method.
 * This is the easiest way to target a given interface.
 * Calling this method sets the interface to use for all the subsequent method calls
 * of the given proxy object.
 * 
 * @subsubsection interface_modifiers Interface modifiers
 * A ServerProxy::Interface "special class" is provided with ServerProxy. Here is how to use it:
 * @code
 * proxy.call("SimpleHello", ServerProxy::Interface("com.example.SampleInterface"), "Hi", &reply); 
 * @endcode
 * This has for effect to place the call on a given interface. This does not change the interface
 * that will be use for subsequent calls.
 * 
 */

/** 
 * @page advanced_features Advanced features
 * 
 * @section datatypes More complex datatypes
 * 
 * DBUSTL does its best not to enforce the used of any data type
 * onto the user of: this makes it easier for DBUSTL to fit with existing
 * C++ toolkits that already have their own containers. This means
 * DBUSTL does not define new objects for the ARRAY, STRUCT, DICT, 
 * and VARIANT DBus data types.
 * 
 * Currently DBUSTL comes with builting support for the following 
 * STL containers.
 * 
 *  <table>
 *  <tr>
 *     <th>Container</th>
 *     <th>Mapped dbus type</th>
 *     <th>Can serialize ?</th>
 *     <th>Can deserialize ?</th>
 *  </tr>
 *  <tr>
 *     <td>std::vector</td>
 *     <td>ARRAY</td>
 *     <td>yes</td>
 *     <td>yes</td>
 *  </tr>
 *  <tr>
 *     <td>std::list</td>
 *     <td>ARRAY</td>
 *     <td>yes</td>
 *     <td>yes</td>
 *  </tr>
 *  <tr>
 *     <td>std::set</td>
 *     <td>ARRAY</td>
 *     <td>yes</td>
 *     <td>yes</td>
 *  </tr>
 *  <tr>
 *     <td>std::multiset</td>
 *     <td>ARRAY</td>
 *     <td>yes</td>
 *     <td>yes</td>
 *  </tr>
 *  <tr>
 *     <td>std::map</td>
 *     <td>DICT</td>
 *     <td>yes</td>
 *     <td>yes</td>
 *  <tr>
 *     <td>std::multimap</td>
 *     <td>DICT</td>
 *     <td>no</td>
 *     <td>yes</td>
 *  </tr>
 *  </table> 
 *  
 * @note std::set: Duplicate array elements are merged during deserialization
 * @note std::multimap: Serialization is not supported as there is no
 * DBUS container able to store the content of a multimap.
 *
 * So let's see how simple this is:
 * 
 * @include containers.cpp
 * 
 * Support for those containers is generated "on the fly" using templates.
 * This means that if Cont is a supported DBUSTL container and T is a supported
 * DBUSTL type, then Cont<T> becomes a DBUSTL supported type.
 * This means that when recursivity comes into play Cont<Cont<T> > becomes
 * a supported type too.
 * Even more than that, you can mix supported containers of different kind, 
 * such as std::map<std::string, std::list<double> > for instance, which
 * works perfectly fine. All is computed behind the scene for you.
 * 
 * As you probably already have understood, DBUSTL is designed to be 
 * extended to support data types other than STL ones. You can even
 * extended to support your own custom program internal data structures
 * as explained in the @ref extending page.
 * 
 * @section async Asynchronous method calls
 * To be written.
 * @section signals Working with signals.
 * To be written.
 */

/** 
 * @page compat_syntax Compatibility syntax
 * 
 * Compatibility syntax is there to allow you to use DBUSTL even
 * if you don't have a C++ compiler that support variadic templates.
 * 
 * The main inconvenient of this alternative approach is that it makes
 * the code a bit more verbose, and far less 'magical':
 * 
 * @include compat.cpp
 * 
 * As you can see this is a bit more complicated that the equivalent
 * code for our @ref hello_world "variadic templates enabled hello world" example.
 * The main issue is the serialization and deserialization of the parameters
 * that are handled should behind the scene, but that have to be exposed
 * here.
 * 
 */

/** 
 * @page design Design paradigms
 * 
 * TODO: explain here why DBUSTL is as it is today
 * 
 */

/** 
 * @page extending Extending DBUSTL to support custom data types
 * 
 * @section custom_struct structs
 * 
 * @section custom_containers containers
 */

/** 
 * @page todo Future improvements
 * 
 * - Implement exceptions less support
 * - Get rid of dbus-glib dependancy, by really implementing GlibEventLoop
 * - Support variants: don't know if that's really used.
 */

#include <dbustl-1/Message>
#include <dbustl-1/Connection>
#include <dbustl-1/ServerProxy>
#include <dbustl-1/types/vector>
#include <dbustl-1/types/list>
#include <dbustl-1/types/set>
#include <dbustl-1/types/map>

