/*
 *  DBusTL - DBus Template Library
 *
 *  Copyright (C) 2008, 2009  Fabien Chevalier <chefabien@gmail.com>
 *  
 *
 *  This file is part of the DBus Template Library.
 *
 *  The DBus Template Library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  DBus Template Library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with DBus Template Library.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef DBUSTL_DBUSOBJECT
#define DBUSTL_DBUSOBJECT

#include <dbus/dbus.h>

#include <string>
#include <map>
#include <list>
#include <set>

#include <dbustl-1/Config>
#include <dbustl-1/DBusException>

#include <dbustl-1/Message>
#include <dbustl-1/Interface>
#include <dbustl-1/types/Tools>

namespace dbustl {

    class Connection;

    class DBusObject {
    public:
        DBusObject(const std::string& objectPath, const std::string& interface, Connection *conn = 0);
        virtual ~DBusObject();

        void setPath(const std::string); //FIXME: To Implement, FIXME broken introspection when path ends with '/'
        std::string path() const { return _objectPath; };
            
        void enable(Connection * conn);
        void disable();

        template<typename _Class, typename R>
        void exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(void), 
            const std::string& interface = "");

        template<typename _Class, typename R, typename T1>
        void exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(T1 arg1), 
            const std::string& interface = "");

        template<typename _Class, typename R, typename T1, typename T2>
        void exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(T1 arg1, T2 arg2), 
            const std::string& interface = "");

        template<typename _Class, typename R, typename T1, typename T2, typename T3>
        void exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(T1 arg1, T2 arg2, T3 arg3), 
            const std::string& interface = "");

        template<typename _Class>
        void exportMethod(const std::string& methodName, _Class *target, 
            void (_Class::*method)(Message method_call), const std::string& interface = "");

        void exportSignal(const std::string& signalName, const std::string& interface = "");    
        template<typename T1>
        void exportSignal(const std::string& signalName, const std::string& interface = "");    
        template<typename T1, typename T2>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3, typename T4>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3, typename T4, typename T5>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
        void exportSignal(const std::string& signalName, const std::string& interface = "");
        template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
        void exportSignal(const std::string& signalName, const std::string& interface = "");

    #ifdef DBUSTL_CXX0X
        template<typename ... Args>
        void emitSignal(const std::string& signalName, const Args&... args);
    #endif

        Message createSignal(const std::string& signalName, const std::string& interface = "");

        void emitSignal(Message& signal);
        
        void sendReply(Message& reply);
  
    private:
        std::string introspect();
        std::string introspectChildren();
     
        /** @cond */
        //This does not show up in doxygen
        class MethodExecutorBase {
        public:
            MethodExecutorBase(const std::string& interface) : _interface(interface) {};
            virtual ~MethodExecutorBase() {};
            virtual void processCall(DBusObject *object, Message* method_call) = 0;
            virtual std::string argsIntrospection() { return ""; };
            const std::string& interface() const { return _interface; };
            void setInterface(const std::string& interface) { _interface = interface; };
        private:
            std::string _interface;
        };
 
        class EasyMethodExecutorBase : public MethodExecutorBase {
        public:
            EasyMethodExecutorBase(const std::string& interface) : MethodExecutorBase(interface) {};
            virtual ~EasyMethodExecutorBase() {};
        private:
            virtual void processCall(DBusObject *object, Message* method_call)
            {
                Message mreturn(method_call->createMethodReturn());
                if(mreturn.dbus()) {
                    processCall(method_call, &mreturn);
                    if(!method_call->error()) {
                        object->sendReply(mreturn);
                    }
                }
            }
            virtual void processCall(Message* method_call, Message *method_return) = 0;
        };

        template<typename T>
        struct remove_const_ref {
            typedef T type;
        };
        
        template<typename T>
        struct remove_const_ref<const T> {
            typedef T type;
        };
        
        template<typename T>
        struct remove_const_ref<T&> {
            typedef T type;
        };
        
        template<typename T>
        struct remove_const_ref<const T&> {
            typedef T type;
        };
        
        template<typename TargetClassType, typename Result>
        class EasyMethodExecutor0 : public EasyMethodExecutorBase {
        public:   
            typedef Result (TargetClassType::*MethodType) (void);
                
            EasyMethodExecutor0(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message*, Message *method_reply)
            {
                *method_reply << (_target->*_method)();
            }

            virtual std::string argsIntrospection()
            {
                std::string intro;
                using namespace types;
                intro = std::string("<arg type=\"") + Signature<typename remove_const_ref<Result>::type>::value() + "\" direction=\"out\"/>";
                return intro;
            }

            TargetClassType *_target;            
            MethodType _method;                
        };
            
        template<typename TargetClassType>
        class EasyMethodExecutor0<TargetClassType, void> : public EasyMethodExecutorBase {
        public:   
            typedef void (TargetClassType::*MethodType) (void);
                
            EasyMethodExecutor0(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message*, Message *)
            {
                (_target->*_method)();
            }

            TargetClassType *_target;            
            MethodType _method;                
        };
            
        template<typename TargetClassType, typename Result, typename T1>
        class EasyMethodExecutor1 : public EasyMethodExecutorBase {
        public:   
            typedef Result (TargetClassType::*MethodType) (T1);
                
            EasyMethodExecutor1(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message* method_call, Message *method_reply)
            {
                typename remove_const_ref<T1>::type a1;
                *method_call >> a1;
                if(method_call->error()) return;
                *method_reply << (_target->*_method)(a1);
            }

            virtual std::string argsIntrospection()
            {
                std::string intro;
                using namespace types;
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T1>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<Result>::type>::value() + "\" direction=\"out\"/>";
                return intro;
            }

            TargetClassType *_target;            
            MethodType _method;                
        };
            
        template<typename TargetClassType, typename T1>
        class EasyMethodExecutor1<TargetClassType, void, T1> : public EasyMethodExecutorBase {
        public:   
            typedef void (TargetClassType::*MethodType) (T1);
                
            EasyMethodExecutor1(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message* method_call, Message *)
            {
                typename remove_const_ref<T1>::type a1;
                *method_call >> a1;
                if(method_call->error()) return;
                (_target->*_method)(a1);
            }

            virtual std::string argsIntrospection()
            {
                std::string intro;
                using namespace types;
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T1>::type>::value() + "\" direction=\"in\"/>";
                return intro;
            }

            TargetClassType *_target;            
            MethodType _method;                
        };
            
        template<typename TargetClassType, typename Result, typename T1, typename T2>
        class EasyMethodExecutor2 : public EasyMethodExecutorBase {
        public:   
            typedef Result (TargetClassType::*MethodType) (T1, T2);
                
            EasyMethodExecutor2(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message* method_call, Message *method_reply)
            {
                typename remove_const_ref<T1>::type a1;
                typename remove_const_ref<T2>::type a2;
                *method_call >> a1;
                *method_call >> a2;
                if(method_call->error()) return;
                *method_reply << (_target->*_method)(a1, a2);
            }

            virtual std::string argsIntrospection()
            {
                std::string intro;
                using namespace types;
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T1>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T2>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<Result>::type>::value() + "\" direction=\"out\"/>";
                return intro;
            }

            TargetClassType *_target;            
            MethodType _method;                
        };

        template<typename TargetClassType, typename T1, typename T2>
        class EasyMethodExecutor2<TargetClassType, void, T1, T2> : public EasyMethodExecutorBase {
        public:   
            typedef void (TargetClassType::*MethodType) (T1, T2);
                
            EasyMethodExecutor2(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message* method_call, Message *)
            {
                typename remove_const_ref<T1>::type a1;
                typename remove_const_ref<T2>::type a2;
                *method_call >> a1;
                *method_call >> a2;
                if(method_call->error()) return;
                (_target->*_method)(a1, a2);
            }

            virtual std::string argsIntrospection()
            {
                std::string intro;
                using namespace types;
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T1>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T2>::type>::value() + "\" direction=\"in\"/>";
                return intro;
            }

            TargetClassType *_target;            
            MethodType _method;                
        };

        template<typename TargetClassType, typename Result, typename T1, typename T2, typename T3>
        class EasyMethodExecutor3 : public EasyMethodExecutorBase {
        public:   
            typedef Result (TargetClassType::*MethodType) (T1, T2, T3);
                
            EasyMethodExecutor3(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message* method_call, Message *method_reply)
            {
                typename remove_const_ref<T1>::type a1;
                typename remove_const_ref<T2>::type a2;
                typename remove_const_ref<T3>::type a3;
                *method_call >> a1;
                *method_call >> a2;
                *method_call >> a3;
                if(method_call->error()) return;
                *method_reply << (_target->*_method)(a1, a2, a3);
            }

            virtual std::string argsIntrospection()
            {
                std::string intro;
                using namespace types;
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T1>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T2>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T3>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<Result>::type>::value() + "\" direction=\"out\"/>";
                return intro;
            }

            TargetClassType *_target;            
            MethodType _method;                
        };

        template<typename TargetClassType, typename T1, typename T2, typename T3>
        class EasyMethodExecutor3<TargetClassType, void, T1, T2, T3> : public EasyMethodExecutorBase {
        public:   
            typedef void (TargetClassType::*MethodType) (T1, T2, T3);
                
            EasyMethodExecutor3(TargetClassType *target, MethodType method, const std::string& interface)
             : EasyMethodExecutorBase(interface), _target(target), _method(method) {};
                
        private:
            virtual void processCall(Message* method_call, Message *)
            {
                typename remove_const_ref<T1>::type a1;
                typename remove_const_ref<T2>::type a2;
                typename remove_const_ref<T3>::type a3;
                *method_call >> a1;
                *method_call >> a2;
                *method_call >> a3;
                if(method_call->error()) return;
                (_target->*_method)(a1, a2, a3);
            }

            virtual std::string argsIntrospection()
            {
                std::string intro;
                using namespace types;
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T1>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T2>::type>::value() + "\" direction=\"in\"/>";
                intro += std::string("<arg type=\"") + Signature<typename remove_const_ref<T3>::type>::value() + "\" direction=\"in\"/>";
                return intro;
            }

            TargetClassType *_target;            
            MethodType _method;                
        };

        template<typename TargetClassType>
        class FlexibleMethodExecutor : public MethodExecutorBase {
        public:
            typedef void (TargetClassType::*MethodType) (Message method_call);
                
            FlexibleMethodExecutor(TargetClassType *target, MethodType method, const std::string& interface)
             : MethodExecutorBase(interface), _target(target), _method(method) {};

        private:
            virtual void processCall(DBusObject *, Message* method_call)
            {
                (_target->*_method)(*method_call);
            }
                
            TargetClassType *_target;            
            MethodType _method;
        };
        /** @endcond */

        void exportMethod(const std::string& methodName, MethodExecutorBase *executor);

        // Signals handling - begin
        class ExportedSignal {
        public:
            ExportedSignal(const std::string& interface) : _interface(interface) {};
            
            const std::string& interface() const
            {
                return _interface;
            };
            
            void setInterface(const std::string& interface)
            {
                _interface = interface;
            };
            
            void addArgument(const std::string& signature)
            {
                _signatures.push_back(signature);
            };
            
            const std::list<std::string>& signatures() const
            {
                return _signatures;
            };
            
            void computeMessageSignature()
            {
                std::list<std::string>::const_iterator it;
                for(it = _signatures.begin(); it != _signatures.end(); ++it) {
                    _messageSignature += *it;
                }
            }
            
            const std::string& messageSignature() const
            {
                return _messageSignature;
            }
            
        private:
            std::string _interface;
            std::list<std::string> _signatures;
            std::string _messageSignature;
        };

        void exportSignal(const std::string& name, ExportedSignal& sig);

    #ifdef DBUSTL_CXX0X
        template<typename T, typename ... Args>
        void processEmitSignalArgs(Message& signal, const T& arg1, const Args&... args);
        
        template<typename ... Args>
        void processEmitSignalArgs(Message& signal, const Interface& intf, const Args&... args);
        
        inline void processEmitSignalArgs(Message& signal);
    #endif
        // Signals handling - end

    #ifdef DBUSTL_NO_EXCEPTIONS
        inline void throw_or_set(const DBusException& error) { _error = error; };
        inline void throw_or_set(const char *name, const char *message) { _error = DBusException(name, message); };
        inline void errorReset() { _error = DBusException(); };
    #else
        static inline void throw_or_set(const DBusException& error) { throw error; };
        static inline void throw_or_set(const char *name, const char *message) { throw DBusException(name, message); };
        static inline void errorReset() {};
    #endif

        Connection *_conn;
        std::string _objectPath;
        std::string _interface;
        typedef std::multimap<std::string, MethodExecutorBase*> MethodContainerType;
        MethodContainerType _exportedMethods;
        typedef std::multimap<std::string, ExportedSignal> ExportedSignalType;
        ExportedSignalType _exportedSignals;
    #ifdef DBUSTL_NO_EXCEPTIONS
        DBusException _error;
    #endif
        
        static DBusHandlerResult incomingMessagesProcessing(DBusConnection *connection, 
            DBusMessage *dbusMessage, void *user_data);
        static DBusObjectPathVTable _vtable;
        
        // List of all objects exported on a connection, needed for introspection support
        static std::map<const Connection*, std::set<const DBusObject*> > _objectTrees;
    };
   
    template<typename _Class, typename R>
    void DBusObject::exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(void), const std::string& interface)
    {
        exportMethod(methodName, new EasyMethodExecutor0<_Class, R>(target, method, interface));
    }

    template<typename _Class, typename R, typename T1>
    void DBusObject::exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(T1 arg1), const std::string& interface)
    {
        exportMethod(methodName, new EasyMethodExecutor1<_Class, R, T1>(target, method, interface));
    }

    template<typename _Class, typename R, typename T1, typename T2>
    void DBusObject::exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(T1 arg1, T2 arg2), const std::string& interface)
    {
        exportMethod(methodName, new EasyMethodExecutor2<_Class, R, T1, T2>(target, method, interface));
    }

    template<typename _Class, typename R, typename T1, typename T2, typename T3>
    void DBusObject::exportMethod(const std::string& methodName, _Class *target, R (_Class::*method)(T1 arg1, T2 arg2, T3 arg), const std::string& interface)
    {
        exportMethod(methodName, new EasyMethodExecutor3<_Class, R, T1, T2, T3>(target, method, interface));
    }

    template<typename _Class>
    void DBusObject::exportMethod(const std::string& methodName, _Class *target, void (_Class::*method)(Message method_call), const std::string& interface)
    {
        exportMethod(methodName, new FlexibleMethodExecutor<_Class>(target, method, interface));
    }

#ifdef DBUSTL_CXX0X
    template<typename ... Args>
    void DBusObject::emitSignal(const std::string& signalName, const Args&... args)
    {
        Message signal(createSignal(signalName));
        processEmitSignalArgs(signal, args...);
    }
#endif

#ifdef DBUSTL_CXX0X
    template<typename T, typename ... Args>
    void DBusObject::processEmitSignalArgs(Message& signal, const T& arg1, const Args&... args)
    {
        signal << arg1;
        processEmitSignalArgs(signal, args...);
    }
#endif

#ifdef DBUSTL_CXX0X
    template<typename ... Args>
    void DBusObject::processEmitSignalArgs(Message& signal, const Interface& intf, const Args&... args)
    {
        dbus_message_set_interface(signal.dbus(), intf.name().c_str());
        processEmitSignalArgs(signal, args...);
    }
#endif
    
#ifdef DBUSTL_CXX0X
    inline void DBusObject::processEmitSignalArgs(Message& signal)
    {
        emitSignal(signal);
    }
#endif

    template<typename T1>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        exportSignal(signalName, s);
    }
    
    template<typename T1, typename T2>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        exportSignal(signalName, s);
    }

    template<typename T1, typename T2, typename T3>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        exportSignal(signalName, s);
    }

    template<typename T1, typename T2, typename T3, typename T4>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        s.addArgument(Signature<T4>::value());
        exportSignal(signalName, s);
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        s.addArgument(Signature<T4>::value());
        s.addArgument(Signature<T5>::value());
        exportSignal(signalName, s);
    }
    
    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        s.addArgument(Signature<T4>::value());
        s.addArgument(Signature<T5>::value());
        s.addArgument(Signature<T6>::value());
        exportSignal(signalName, s);
    }
    
    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        s.addArgument(Signature<T4>::value());
        s.addArgument(Signature<T5>::value());
        s.addArgument(Signature<T6>::value());
        s.addArgument(Signature<T7>::value());
        exportSignal(signalName, s);
    }
    
    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        s.addArgument(Signature<T4>::value());
        s.addArgument(Signature<T5>::value());
        s.addArgument(Signature<T6>::value());
        s.addArgument(Signature<T7>::value());
        s.addArgument(Signature<T8>::value());
        exportSignal(signalName, s);
    }
    
    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        s.addArgument(Signature<T4>::value());
        s.addArgument(Signature<T5>::value());
        s.addArgument(Signature<T6>::value());
        s.addArgument(Signature<T7>::value());
        s.addArgument(Signature<T8>::value());
        s.addArgument(Signature<T9>::value());
        exportSignal(signalName, s);
    }
    
    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
    void DBusObject::exportSignal(const std::string& signalName, const std::string& interface)
    {
        using namespace types;
        ExportedSignal s(interface);
        s.addArgument(Signature<T1>::value());
        s.addArgument(Signature<T2>::value());
        s.addArgument(Signature<T3>::value());
        s.addArgument(Signature<T4>::value());
        s.addArgument(Signature<T5>::value());
        s.addArgument(Signature<T6>::value());
        s.addArgument(Signature<T7>::value());
        s.addArgument(Signature<T8>::value());
        s.addArgument(Signature<T9>::value());
        s.addArgument(Signature<T10>::value());
        exportSignal(signalName, s);
    }
}

#endif /* DBUSTL_DBUSOBJECT */
