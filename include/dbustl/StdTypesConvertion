#ifndef DBUSTL_STDTYPESCONVERTION
#define DBUSTL_STDTYPESCONVERTION

// STL to DBUS arguments types mapping

#include <string>
#include <cassert>
#include <dbus/dbus.h>

namespace dbustl {
  
    /* integral types */
    
    //helper functions
    template<typename T> 
    inline bool __serializeSignedIntegral(DBusMessageIter* it, const T& arg)
    {
        int dbus_type = DBUS_TYPE_INVALID;
        switch(sizeof(arg)) {
            case 2:
                dbus_type = DBUS_TYPE_INT16;
                break;
            case 4:
                dbus_type = DBUS_TYPE_INT32;
                break;
            case 8:
                dbus_type = DBUS_TYPE_INT64;
                break;
            default:
                assert("The supplied argument does not match any integer size supported by DBUS");
        }
        if(dbus_type != DBUS_TYPE_INVALID) {
            return dbus_message_iter_append_basic(it, dbus_type, &arg);
        }
        else {
            return false;
        }
    }

    template<typename T> 
    inline bool __serializeUnsignedIntegral(DBusMessageIter* it, const T& arg)
    {
        int dbus_type = DBUS_TYPE_INVALID;
        switch(sizeof(arg)) {
            case 1:
                dbus_type = DBUS_TYPE_BYTE;
                break;
            case 2:
                dbus_type = DBUS_TYPE_UINT16;
                break;
            case 4:
                dbus_type = DBUS_TYPE_UINT32;
                break;
            case 8:
                dbus_type = DBUS_TYPE_UINT64;
                break;
            default:
                assert("The supplied argument does not match any integer size supported by DBUS");
        }
        if(dbus_type != DBUS_TYPE_INVALID) {
            return dbus_message_iter_append_basic(it, dbus_type, &arg);
        }
        else {
            return false;
        }
    }
    
    /* bool */
    template<> dbus_bool_t serialize<bool>(DBusMessageIter* it, const bool& arg)
    {
        return dbus_message_iter_append_basic(it, DBUS_TYPE_BOOLEAN, &arg);
    }
    template<> dbus_bool_t deserialize<bool>(DBusMessageIter* it, bool *arg)
    {
        if(dbus_message_iter_get_arg_type(it) != DBUS_TYPE_BOOLEAN) {
            return FALSE;
        }
        dbus_message_iter_get_basic(it, arg);
        return TRUE;
    }

    /* char */
    template<> dbus_bool_t serialize<char>(DBusMessageIter* it, const char& arg)
    {
        return __serializeUnsignedIntegral<char>(it, arg);
    }

    /* signed char */
    template<> dbus_bool_t serialize<signed char>(DBusMessageIter* it, const signed char& arg)
    {
        return __serializeSignedIntegral<signed char>(it, arg);
    }

    /* unsigned char */
    template<> dbus_bool_t serialize<unsigned char>(DBusMessageIter* it, const unsigned char& arg)
    {
        return __serializeUnsignedIntegral<unsigned char>(it, arg);
    }

    /* short */
    template<> dbus_bool_t serialize<short>(DBusMessageIter* it, const short& arg)
    {
        return __serializeSignedIntegral<short>(it, arg);
    }

    /* unsigned short */
    template<> dbus_bool_t serialize<unsigned short>(DBusMessageIter* it, const unsigned short& arg)
    {
        return __serializeUnsignedIntegral<unsigned short>(it, arg);
    }

    /* int */
    template<> dbus_bool_t serialize<int>(DBusMessageIter* it, const int& arg)
    {
        return __serializeSignedIntegral<int>(it, arg);
    }

    /* unsigned int */
    template<> dbus_bool_t serialize<unsigned int>(DBusMessageIter* it, const unsigned int& arg)
    {
        return __serializeUnsignedIntegral<unsigned int>(it, arg);
    }

    /* long */
    template<> dbus_bool_t serialize<long>(DBusMessageIter* it, const long& arg)
    {
        return __serializeSignedIntegral<long>(it, arg);
    }

    /* unsigned long */
    template<> dbus_bool_t serialize<unsigned long>(DBusMessageIter* it, const unsigned long& arg)
    {
        return __serializeUnsignedIntegral<unsigned long>(it, arg);
    }

    /* long long */
    template<> dbus_bool_t serialize<long long>(DBusMessageIter* it, const long long& arg)
    {
        return __serializeSignedIntegral<long long>(it, arg);
    }

    /* unsigned long long */
    template<> dbus_bool_t serialize<unsigned long long>(DBusMessageIter* it, const unsigned long long& arg)
    {
        return __serializeUnsignedIntegral<unsigned long long>(it, arg);
    }

    /* double */
    template<> dbus_bool_t serialize<double>(DBusMessageIter* it, const double& arg)
    {
        return dbus_message_iter_append_basic(it, DBUS_TYPE_DOUBLE, &arg);
    }
    template<> dbus_bool_t deserialize<double>(DBusMessageIter* it, double *arg)
    {
        if(dbus_message_iter_get_arg_type(it) != DBUS_TYPE_DOUBLE) {
            return FALSE;
        }
        dbus_message_iter_get_basic(it, arg);
        return TRUE;
    }

    /* const char* */
    template<> dbus_bool_t serialize<const char*>(DBusMessageIter* it, const char* const& arg)
    {
        return dbus_message_iter_append_basic(it, DBUS_TYPE_STRING, &arg);
    }
    
    /* std::string */
    template<> dbus_bool_t serialize<std::string>(DBusMessageIter* it, const std::string& arg)
    {
        const char *cstring = arg.c_str();
        return dbus_message_iter_append_basic(it, DBUS_TYPE_STRING, &cstring);
    }
    template<> dbus_bool_t deserialize<std::string>(DBusMessageIter* it, std::string* arg)
    {
        const char *str;
        if(dbus_message_iter_get_arg_type(it) != DBUS_TYPE_STRING) {
            return FALSE;
        }
        dbus_message_iter_get_basic(it, &str);
        *arg = str;
        return TRUE;
    }

}

#endif
