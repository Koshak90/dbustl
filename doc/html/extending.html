<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DBus Template Library: Extending DBUSTL to support custom data types</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="extending">Extending DBUSTL to support custom data types </a></h1>DBUSTL can be extended to support program-specific data types in two different way.<p>
First way(and easy way) is by allowing user to map their own data structures into DBus structs.<p>
The second way(and more complex way) allows to map any user defined data type onto any DBUS message. This is allows for complete customization, with no limitation.<h2><a class="anchor" name="custom_struct">
Structs</a></h2>
<h3><a class="anchor" name="cumstom_structs_theory">
How it works</a></h3>
The C++ language does not allow for compile time discovery of a given structure's fields. What this means is that there is currently no way DBUSTL can dynamically learn how to handle user defined structs.<p>
The consequence is that user defined structs must be registered to DBUSTL to be usable. Registering requires providing a set of template specializations. As the details can sometimes be tricky, they are hidden behind a set of do-it-all-for-you macros called DBUSTL_REGISTER_STRUCT_N(structname, field1, field2, ...., fieldN), where N is between 1 and 6.<p>
All you have to do is call the macro once in a dedicated source file, and add this source file to your project.<h3><a class="anchor" name="cumstom_structs_example">
An example</a></h3>
On our example, we register a Struct called ExampleStruct, and then use it with DBUSTL.<p>
struct1.h containts the structure definition: <div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
 
<span class="keyword">struct </span>ExampleStruct {
        std::string field1;
        <span class="keywordtype">double</span> field2;
        std::vector&lt;int&gt; field3;
};
</pre></div> struct1.cpp containts the structure registration: <div class="fragment"><pre class="fragment">
<span class="preprocessor">#include "struct1.h"</span>
<span class="preprocessor">#include &lt;<a class="code" href="dbustl.html">dbustl-1/dbustl</a>&gt;</span>

DBUSTL_REGISTER_STRUCT_3(
    ExampleStruct, 
    field1, 
    field2, 
    field3
)
</pre></div> struct2.cpp containts the calling sequence: <div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;<a class="code" href="dbustl.html">dbustl-1/dbustl</a>&gt;</span>

<span class="preprocessor">#include "struct1.h"</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>dbustl;
 
<span class="keywordtype">int</span> main()
{
    ServerProxy remoteObject(Connection::sessionBus(), 
    <span class="stringliteral">"/PythonServerObject"</span>, <span class="stringliteral">"com.example.SampleService"</span>);
    <span class="keywordflow">try</span> {
        ExampleStruct s1, s2;
        s1.field1 = <span class="stringliteral">"String"</span>;
        s1.field2 = 1.1;
        remoteObject.call(<span class="stringliteral">"test_ExampleStruct"</span>, s1, &amp;s2); 
        cout &lt;&lt; s1.field1 &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; s1.field2 &lt;&lt; endl;
    }
    <span class="keywordflow">catch</span>(<span class="keyword">const</span> DBusException&amp; e) {
        <span class="comment">/* Dbus call failed: e.name() constains error cause */</span>
        cerr &lt;&lt; e.what() &lt;&lt; endl;
    } 
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>1: Apart from registration step, the use of structure is completely transparent. <p>
2: C++ classes can be serialized or deserialized the same way as C structs. The only limitation is that the members must be public.</dd></dl>
<h2><a class="anchor" name="custom_containers">
Any other data type</a></h2>
DBUSTL can be extended to support any data type, as well as any container type.<p>
The extension mechanism is similar to what is used natively by DBUSTL to support the standard STL containers. It relies on template specializations. The following class templates need to be specialized so as to support a new type: <div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">struct </span>Serializer {
        <span class="keyword">static</span> dbus_bool_t run(DBusMessageIter* it, <span class="keyword">const</span> T&amp; arg);
    };
    
    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">struct </span>Deserializer {
        <span class="keyword">static</span> dbus_bool_t run(DBusMessageIter* it, T* arg);
    };
</pre></div> In addition, if you intend to be able to put your type as the value of a DBus Dict, you will need to specialize this one: <div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">struct </span>Signature {
        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* value();
    };
</pre></div><p>
For more details on how to do it, having a look in the include/dbustl-1/types directory will help you to understand how it is done for STL containers. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Mar 23 21:52:39 2009 for DBus Template Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
