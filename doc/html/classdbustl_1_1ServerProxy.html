<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DBus Template Library: dbustl::ServerProxy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacedbustl.html">dbustl</a>::<a class="el" href="classdbustl_1_1ServerProxy.html">ServerProxy</a>
  </div>
</div>
<div class="contents">
<h1>dbustl::ServerProxy Class Reference</h1><!-- doxytag: class="dbustl::ServerProxy" -->Defines a proxy, used to call methods an receive signals on a remote DBus object.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classdbustl_1_1ServerProxy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Proxy settings</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#c3df3a25dec4e1cfdd1f89452e64aa2f">ServerProxy</a> (<a class="el" href="classdbustl_1_1Connection.html">Connection</a> *conn, const std::string &amp;path, const std::string &amp;destination=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a proxy for the object uniquely identified by the (conn, path, destination) triplet.  <a href="#c3df3a25dec4e1cfdd1f89452e64aa2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#630ebc97581da1e76973ac7b5edaef3b">~ServerProxy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#630ebc97581da1e76973ac7b5edaef3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#941e591f7b3b08d807dfdc1577e9a656">setTimeout</a> (int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For synchronous blocking calls, set the timeout in milliseconds.  <a href="#941e591f7b3b08d807dfdc1577e9a656"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#df5a271c2cd99518f4977f8591cf8b8c">setInterface</a> (const std::string &amp;interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the interface to use for all the calls on the remote object.  <a href="#df5a271c2cd99518f4977f8591cf8b8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#000cbff205ee549e3bff11e2af47c1d8">error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In case exception are not enabled, returns the last error that happened.  <a href="#000cbff205ee549e3bff11e2af47c1d8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Synchronous calls handling</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#5f2cfa8fd8a11fa26e71649d97382edf">call</a> (const std::string &amp;methodName, const Args &amp;...args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a DBUS method on a remote object.  <a href="#5f2cfa8fd8a11fa26e71649d97382edf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdbustl_1_1Message.html">Message</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#4a48b5f46d130475aa7cdf619fbef883">createMethodCall</a> (const std::string &amp;methodName) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compatibility C++ syntax: Creates a method call message.  <a href="#4a48b5f46d130475aa7cdf619fbef883"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdbustl_1_1Message.html">Message</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#9d1533ead0f132c6950f1819780a6c53">call</a> (<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;methodCall)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compatibility C++ syntax: Executes a DBUS method call.  <a href="#9d1533ead0f132c6950f1819780a6c53"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Asynchronous calls handling</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MethodCallback, typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#db058c8465d4c2195583228846c1cf11">asyncCall</a> (const std::string &amp;methodName, const MethodCallback &amp;callback, const Args &amp;...args)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#c2df8d6a5a264a6a7f10971c0c43834e">asyncCall</a> (const std::string &amp;methodName, void(*callback)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;), const Args &amp;...args)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename _Class, typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#d984748cd58e241e43e06d8cf681b370">asyncCall</a> (const std::string &amp;methodName, void(_Class::*callback)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;), _Class *c, const Args &amp;...args)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MethodCallback&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#e412d79e3d13e19b24a6378b00853c94">asyncCall</a> (<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;method_call, const MethodCallback &amp;callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#679e2aa906acdd9f85e975b1fb6bfaa5">asyncCall</a> (<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;method_call, void(*callback)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;))</td></tr>

<tr><td colspan="2"><br><h2>Signals handling</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SignalHandlerFunctor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#c332e372e364eb981189dfc1eb5d5d2d">setSignalHandler</a> (const std::string &amp;signalName, const SignalHandlerFunctor &amp;handler)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#42d95ef01b473ec279dd5abe14ce405d">setSignalHandler</a> (const std::string &amp;signalName, void(*handler)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;signal))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename _Class&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#fabf40a8dda083184aeaae65962ec165">setSignalHandler</a> (const std::string &amp;signalName, void(_Class::*handler)(<a class="el" href="classdbustl_1_1Message.html">Message</a> signal), _Class *c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#353cd4b5e6178664439333b576754805">removeSignalHandler</a> (const std::string &amp;signalName)</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy_1_1Interface.html">Interface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used in <a class="el" href="classdbustl_1_1ServerProxy.html#5f2cfa8fd8a11fa26e71649d97382edf" title="Calls a DBUS method on a remote object.">call()</a> member of <a class="el" href="classdbustl_1_1ServerProxy.html" title="Defines a proxy, used to call methods an receive signals on a remote DBus object...">ServerProxy</a> class to use an alternative <a class="el" href="classdbustl_1_1ServerProxy_1_1Interface.html" title="This class is used in call() member of ServerProxy class to use an alternative Interface...">Interface</a> name for that particular method call only.  <a href="classdbustl_1_1ServerProxy_1_1Interface.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Defines a proxy, used to call methods an receive signals on a remote DBus object. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c3df3a25dec4e1cfdd1f89452e64aa2f"></a><!-- doxytag: member="dbustl::ServerProxy::ServerProxy" ref="c3df3a25dec4e1cfdd1f89452e64aa2f" args="(Connection *conn, const std::string &amp;path, const std::string &amp;destination=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dbustl::ServerProxy::ServerProxy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a proxy for the object uniquely identified by the (conn, path, destination) triplet. 
<p>
Beware: It is a design error to create more that one proxy on the same object on the same connection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conn</em>&nbsp;</td><td>The DBus <a class="el" href="classdbustl_1_1Connection.html" title="Provides an abstraction of a DBus Connection.">Connection</a> used on which the object to call on is found. Usually one of <a class="el" href="classdbustl_1_1Connection.html#6d69849fdbe4f404cb59a0c1e2633ea2" title="Returns a singleton to the system bus.">Connection::systemBus</a> or <a class="el" href="classdbustl_1_1Connection.html#3de1e85aa0f4041106bb0e885abfc348" title="Returns a singleton to the session bus.">Connection::sessionBus</a>. The conn object must remain valid until the proxy object is destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The DBus object path of the target objet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The DBus connection name on the given bus where the object we which to call on is found. Destination is only required if this connection talks to a message bus. In this case it must contain the name of the connection this message is intended for. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="630ebc97581da1e76973ac7b5edaef3b"></a><!-- doxytag: member="dbustl::ServerProxy::~ServerProxy" ref="630ebc97581da1e76973ac7b5edaef3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dbustl::ServerProxy::~ServerProxy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
The destructor is non virtual on purpose, this class is not designed for inheritance. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="941e591f7b3b08d807dfdc1577e9a656"></a><!-- doxytag: member="dbustl::ServerProxy::setTimeout" ref="941e591f7b3b08d807dfdc1577e9a656" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::setTimeout           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For synchronous blocking calls, set the timeout in milliseconds. 
<p>
-1 means default value (very long) 
</div>
</div><p>
<a class="anchor" name="df5a271c2cd99518f4977f8591cf8b8c"></a><!-- doxytag: member="dbustl::ServerProxy::setInterface" ref="df5a271c2cd99518f4977f8591cf8b8c" args="(const std::string &amp;interface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::setInterface           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the interface to use for all the calls on the remote object. 
<p>
If empty (the default), the default interface is used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interface</em>&nbsp;</td><td>dbus interface name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="000cbff205ee549e3bff11e2af47c1d8"></a><!-- doxytag: member="dbustl::ServerProxy::error" ref="000cbff205ee549e3bff11e2af47c1d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a>&amp; dbustl::ServerProxy::error           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
In case exception are not enabled, returns the last error that happened. 
<p>

</div>
</div><p>
<a class="anchor" name="5f2cfa8fd8a11fa26e71649d97382edf"></a><!-- doxytag: member="dbustl::ServerProxy::call" ref="5f2cfa8fd8a11fa26e71649d97382edf" args="(const std::string &amp;methodName, const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::call           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a DBUS method on a remote object. 
<p>
This blocks until the reply is received or a timeout occurs. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>methodName</em>&nbsp;</td><td>the name of the DBUS method to call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>A list of input parameters passed by references, followed by a list of output parameters passed as pointers. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBUSTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if anything goes wrong </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4a48b5f46d130475aa7cdf619fbef883"></a><!-- doxytag: member="dbustl::ServerProxy::createMethodCall" ref="4a48b5f46d130475aa7cdf619fbef883" args="(const std::string &amp;methodName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdbustl_1_1Message.html">Message</a> dbustl::ServerProxy::createMethodCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compatibility C++ syntax: Creates a method call message. 
<p>
see <a class="el" href="compat_syntax.html">Compatibility syntax</a> for more details <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>methodName</em>&nbsp;</td><td>the name of the DBUS method to call </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBUSTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if anything goes wrong </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d1533ead0f132c6950f1819780a6c53"></a><!-- doxytag: member="dbustl::ServerProxy::call" ref="9d1533ead0f132c6950f1819780a6c53" args="(Message &amp;methodCall)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdbustl_1_1Message.html">Message</a> dbustl::ServerProxy::call           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>methodCall</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compatibility C++ syntax: Executes a DBUS method call. 
<p>
Sends the message over the wire and waits for the answer.<p>
see <a class="el" href="compat_syntax.html">Compatibility syntax</a> for more details <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>methodCall</em>&nbsp;</td><td>a message created by createMethodCall </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBUSTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if anything goes wrong </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="db058c8465d4c2195583228846c1cf11"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="db058c8465d4c2195583228846c1cf11" args="(const std::string &amp;methodName, const MethodCallback &amp;callback, const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MethodCallback, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MethodCallback &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c2df8d6a5a264a6a7f10971c0c43834e"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="c2df8d6a5a264a6a7f10971c0c43834e" args="(const std::string &amp;methodName, void(*callback)(Message &amp;, const DBusException &amp;), const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;)&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d984748cd58e241e43e06d8cf681b370"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="d984748cd58e241e43e06d8cf681b370" args="(const std::string &amp;methodName, void(_Class::*callback)(Message &amp;, const DBusException &amp;), _Class *c, const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Class, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(_Class::*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;)&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Class *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e412d79e3d13e19b24a6378b00853c94"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="e412d79e3d13e19b24a6378b00853c94" args="(Message &amp;method_call, const MethodCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MethodCallback&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MethodCallback &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="679e2aa906acdd9f85e975b1fb6bfaa5"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="679e2aa906acdd9f85e975b1fb6bfaa5" args="(Message &amp;method_call, void(*callback)(Message &amp;, const DBusException &amp;))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;)&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c332e372e364eb981189dfc1eb5d5d2d"></a><!-- doxytag: member="dbustl::ServerProxy::setSignalHandler" ref="c332e372e364eb981189dfc1eb5d5d2d" args="(const std::string &amp;signalName, const SignalHandlerFunctor &amp;handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignalHandlerFunctor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::setSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignalHandlerFunctor &amp;&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="42d95ef01b473ec279dd5abe14ce405d"></a><!-- doxytag: member="dbustl::ServerProxy::setSignalHandler" ref="42d95ef01b473ec279dd5abe14ce405d" args="(const std::string &amp;signalName, void(*handler)(Message &amp;signal))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::setSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;signal)&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fabf40a8dda083184aeaae65962ec165"></a><!-- doxytag: member="dbustl::ServerProxy::setSignalHandler" ref="fabf40a8dda083184aeaae65962ec165" args="(const std::string &amp;signalName, void(_Class::*handler)(Message signal), _Class *c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Class&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::setSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(_Class::*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> signal)&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Class *&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="353cd4b5e6178664439333b576754805"></a><!-- doxytag: member="dbustl::ServerProxy::removeSignalHandler" ref="353cd4b5e6178664439333b576754805" args="(const std::string &amp;signalName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dbustl::ServerProxy::removeSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>dbustl-1/<a class="el" href="ServerProxy.html">ServerProxy</a><li><a class="el" href="ServerProxy_8cpp.html">ServerProxy.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>DBus Template Library 0.2.0 documentation, generated by &nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
