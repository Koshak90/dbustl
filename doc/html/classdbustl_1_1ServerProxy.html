<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DBus Template Library: dbustl::ServerProxy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>dbustl</b>::<a class="el" href="classdbustl_1_1ServerProxy.html">ServerProxy</a>
  </div>
</div>
<div class="contents">
<h1>dbustl::ServerProxy Class Reference</h1><!-- doxytag: class="dbustl::ServerProxy" -->Defines a proxy, used to call methods an receive signals on a remote DBus object.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classdbustl_1_1ServerProxy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Proxy settings</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#c3df3a25dec4e1cfdd1f89452e64aa2f">ServerProxy</a> (<a class="el" href="classdbustl_1_1Connection.html">Connection</a> *conn, const std::string &amp;path, const std::string &amp;destination=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a proxy for the object uniquely identified by the (conn, path, destination) triplet.  <a href="#c3df3a25dec4e1cfdd1f89452e64aa2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#630ebc97581da1e76973ac7b5edaef3b">~ServerProxy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#630ebc97581da1e76973ac7b5edaef3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#941e591f7b3b08d807dfdc1577e9a656">setTimeout</a> (int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For synchronous blocking calls, set the timeout in milliseconds.  <a href="#941e591f7b3b08d807dfdc1577e9a656"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#df5a271c2cd99518f4977f8591cf8b8c">setInterface</a> (const std::string &amp;interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the interface to use for all the calls on the remote object.  <a href="#df5a271c2cd99518f4977f8591cf8b8c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Synchronous calls handling</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#c2ba5238dfd4c216204da9ba287e99df">call</a> (const std::string &amp;methodName, const Args &amp;...args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a DBUS method on a remote object.  <a href="#c2ba5238dfd4c216204da9ba287e99df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdbustl_1_1Message.html">Message</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#50d188516cd98b83b010cc8b25a0e453">createMethodCall</a> (const std::string &amp;methodName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compatibility C++ syntax: Creates a method call message.  <a href="#50d188516cd98b83b010cc8b25a0e453"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdbustl_1_1Message.html">Message</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#9d1533ead0f132c6950f1819780a6c53">call</a> (<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;methodCall)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compatibility C++ syntax: Executes a DBUS method call.  <a href="#9d1533ead0f132c6950f1819780a6c53"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Asynchronous calls handling</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MethodCallback, typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#d51f05cc233fcc2bde1c68a80131dfd7">asyncCall</a> (const std::string &amp;methodName, const MethodCallback &amp;callback, const Args &amp;...args)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#b30380def900f23eac1a127cdc54d0b5">asyncCall</a> (const std::string &amp;methodName, void(*callback)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;), const Args &amp;...args)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename _Class, typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#1545721988fa71b8a57f798af485e3aa">asyncCall</a> (const std::string &amp;methodName, void(_Class::*callback)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;), _Class *c, const Args &amp;...args)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MethodCallback&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#e412d79e3d13e19b24a6378b00853c94">asyncCall</a> (<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;method_call, const MethodCallback &amp;callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#679e2aa906acdd9f85e975b1fb6bfaa5">asyncCall</a> (<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;method_call, void(*callback)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;))</td></tr>

<tr><td colspan="2"><br><h2>Signals handling</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SignalHandlerFunctor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#0ce3928d90c9332a0ef7fdd2fdb98362">setSignalHandler</a> (const std::string &amp;signalName, const SignalHandlerFunctor &amp;handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a handler to receive a DBUS signal : C++ functor version.  <a href="#0ce3928d90c9332a0ef7fdd2fdb98362"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#599f5cd96de569f5e14664896ba52610">setSignalHandler</a> (const std::string &amp;signalName, void(*handler)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;signal))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a handler to receive a DBUS signal : function pointer version.  <a href="#599f5cd96de569f5e14664896ba52610"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename _Class&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#089709f5132e105f0f57b4025218b93e">setSignalHandler</a> (const std::string &amp;signalName, void(_Class::*handler)(<a class="el" href="classdbustl_1_1Message.html">Message</a> signal), _Class *object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a handler to receive a DBUS signal : member pointer version.  <a href="#089709f5132e105f0f57b4025218b93e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy.html#fe875b185faaf41a2648d4a862e92091">removeSignalHandler</a> (const std::string &amp;signalName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a signal handler previously registered with <a class="el" href="classdbustl_1_1ServerProxy.html#0ce3928d90c9332a0ef7fdd2fdb98362" title="Registers a handler to receive a DBUS signal : C++ functor version.">setSignalHandler()</a>.  <a href="#fe875b185faaf41a2648d4a862e92091"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbustl_1_1ServerProxy_1_1Interface.html">Interface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used in <a class="el" href="classdbustl_1_1ServerProxy.html#c2ba5238dfd4c216204da9ba287e99df" title="Calls a DBUS method on a remote object.">call()</a> member of <a class="el" href="classdbustl_1_1ServerProxy.html" title="Defines a proxy, used to call methods an receive signals on a remote DBus object...">ServerProxy</a> class to use an alternative <a class="el" href="classdbustl_1_1ServerProxy_1_1Interface.html" title="This class is used in call() member of ServerProxy class to use an alternative Interface...">Interface</a> name for that particular method call only.  <a href="classdbustl_1_1ServerProxy_1_1Interface.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Defines a proxy, used to call methods an receive signals on a remote DBus object. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c3df3a25dec4e1cfdd1f89452e64aa2f"></a><!-- doxytag: member="dbustl::ServerProxy::ServerProxy" ref="c3df3a25dec4e1cfdd1f89452e64aa2f" args="(Connection *conn, const std::string &amp;path, const std::string &amp;destination=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dbustl::ServerProxy::ServerProxy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a proxy for the object uniquely identified by the (conn, path, destination) triplet. 
<p>
Beware: It is a design error to create more that one proxy on the same object on the same connection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conn</em>&nbsp;</td><td>The DBus <a class="el" href="classdbustl_1_1Connection.html" title="Provides an abstraction of a DBus Connection.">Connection</a> used on which the object to call on is found. Usually one of <a class="el" href="classdbustl_1_1Connection.html#d596fa470f78e1152d234ee93dfd64e5" title="Returns a singleton to the system bus.">Connection::systemBus</a> or <a class="el" href="classdbustl_1_1Connection.html#5dd064d01bb7100810e51660443a825f" title="Returns a singleton to the session bus.">Connection::sessionBus</a>. The conn object must remain valid until the proxy object is destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The DBus object path of the target objet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The DBus connection name on the given bus where the object we which to call on is found. Destination is only required if this connection talks to a message bus. In this case it must contain the name of the connection this message is intended for. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="630ebc97581da1e76973ac7b5edaef3b"></a><!-- doxytag: member="dbustl::ServerProxy::~ServerProxy" ref="630ebc97581da1e76973ac7b5edaef3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dbustl::ServerProxy::~ServerProxy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
The destructor is non virtual on purpose, this class is not designed for inheritance. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="941e591f7b3b08d807dfdc1577e9a656"></a><!-- doxytag: member="dbustl::ServerProxy::setTimeout" ref="941e591f7b3b08d807dfdc1577e9a656" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::setTimeout           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For synchronous blocking calls, set the timeout in milliseconds. 
<p>
-1 means default value (very long) 
</div>
</div><p>
<a class="anchor" name="df5a271c2cd99518f4977f8591cf8b8c"></a><!-- doxytag: member="dbustl::ServerProxy::setInterface" ref="df5a271c2cd99518f4977f8591cf8b8c" args="(const std::string &amp;interface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::setInterface           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the interface to use for all the calls on the remote object. 
<p>
If empty (the default), the default interface is used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interface</em>&nbsp;</td><td>dbus interface name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c2ba5238dfd4c216204da9ba287e99df"></a><!-- doxytag: member="dbustl::ServerProxy::call" ref="c2ba5238dfd4c216204da9ba287e99df" args="(const std::string &amp;methodName, const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::call           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a DBUS method on a remote object. 
<p>
This blocks until the reply is received or a timeout occurs. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>methodName</em>&nbsp;</td><td>the name of the DBUS method to call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>A list of input parameters passed by references, followed by a list of output parameters passed as pointers. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBusTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if anything goes wrong </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="50d188516cd98b83b010cc8b25a0e453"></a><!-- doxytag: member="dbustl::ServerProxy::createMethodCall" ref="50d188516cd98b83b010cc8b25a0e453" args="(const std::string &amp;methodName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdbustl_1_1Message.html">Message</a> dbustl::ServerProxy::createMethodCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compatibility C++ syntax: Creates a method call message. 
<p>
see <a class="el" href="compat_syntax.html">Compatibility syntax</a> for more details <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>methodName</em>&nbsp;</td><td>the name of the DBUS method to call </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBusTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if anything goes wrong </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d1533ead0f132c6950f1819780a6c53"></a><!-- doxytag: member="dbustl::ServerProxy::call" ref="9d1533ead0f132c6950f1819780a6c53" args="(Message &amp;methodCall)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdbustl_1_1Message.html">Message</a> dbustl::ServerProxy::call           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>methodCall</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compatibility C++ syntax: Executes a DBUS method call. 
<p>
Sends the message over the wire and waits for the answer.<p>
see <a class="el" href="compat_syntax.html">Compatibility syntax</a> for more details <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>methodCall</em>&nbsp;</td><td>a message created by createMethodCall </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBusTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if anything goes wrong </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d51f05cc233fcc2bde1c68a80131dfd7"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="d51f05cc233fcc2bde1c68a80131dfd7" args="(const std::string &amp;methodName, const MethodCallback &amp;callback, const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MethodCallback, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MethodCallback &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b30380def900f23eac1a127cdc54d0b5"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="b30380def900f23eac1a127cdc54d0b5" args="(const std::string &amp;methodName, void(*callback)(Message &amp;, const DBusException &amp;), const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;)&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1545721988fa71b8a57f798af485e3aa"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="1545721988fa71b8a57f798af485e3aa" args="(const std::string &amp;methodName, void(_Class::*callback)(Message &amp;, const DBusException &amp;), _Class *c, const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Class, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(_Class::*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;)&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Class *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e412d79e3d13e19b24a6378b00853c94"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="e412d79e3d13e19b24a6378b00853c94" args="(Message &amp;method_call, const MethodCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MethodCallback&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MethodCallback &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="679e2aa906acdd9f85e975b1fb6bfaa5"></a><!-- doxytag: member="dbustl::ServerProxy::asyncCall" ref="679e2aa906acdd9f85e975b1fb6bfaa5" args="(Message &amp;method_call, void(*callback)(Message &amp;, const DBusException &amp;))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::asyncCall           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;, const <a class="el" href="classdbustl_1_1DBusException.html">DBusException</a> &amp;)&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0ce3928d90c9332a0ef7fdd2fdb98362"></a><!-- doxytag: member="dbustl::ServerProxy::setSignalHandler" ref="0ce3928d90c9332a0ef7fdd2fdb98362" args="(const std::string &amp;signalName, const SignalHandlerFunctor &amp;handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignalHandlerFunctor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::setSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignalHandlerFunctor &amp;&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a handler to receive a DBUS signal : C++ functor version. 
<p>
If a handler is already registered, the previous handler is overwritten with the new one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signalName</em>&nbsp;</td><td>The name of the message to receive. If set to an empty string, all signals are received, unless another signal handler with and exact match on the signal name is registered at the time the signal is received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>the handlers' operator() will be called each time a matching signal is received. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBusTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if signalName is invalid. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="599f5cd96de569f5e14664896ba52610"></a><!-- doxytag: member="dbustl::ServerProxy::setSignalHandler" ref="599f5cd96de569f5e14664896ba52610" args="(const std::string &amp;signalName, void(*handler)(Message &amp;signal))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::setSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> &amp;signal)&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a handler to receive a DBUS signal : function pointer version. 
<p>
If a handler is already registered, the previous handler is overwritten with the new one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signalName</em>&nbsp;</td><td>The name of the message to receive. If set to an empty string, all signals are received, unless another signal handler with and exact match on the signal name is registered at the time the signal is received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>the handler will be called back each time a matching signal is received. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBusTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if signalName is invalid. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="089709f5132e105f0f57b4025218b93e"></a><!-- doxytag: member="dbustl::ServerProxy::setSignalHandler" ref="089709f5132e105f0f57b4025218b93e" args="(const std::string &amp;signalName, void(_Class::*handler)(Message signal), _Class *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Class&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::setSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(_Class::*)(<a class="el" href="classdbustl_1_1Message.html">Message</a> signal)&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Class *&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a handler to receive a DBUS signal : member pointer version. 
<p>
If a handler is already registered, the previous handler is overwritten with the new one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signalName</em>&nbsp;</td><td>The name of the mesignalssage to receive. If set to an empty string, all signals are received, unless another signal handler with and exact match on the signal name is registered at the time the signal is received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>this member function will be called back each time a matching signal is received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>the handler member function the object will be called with? </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBusTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if signalName is invalid. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fe875b185faaf41a2648d4a862e92091"></a><!-- doxytag: member="dbustl::ServerProxy::removeSignalHandler" ref="fe875b185faaf41a2648d4a862e92091" args="(const std::string &amp;signalName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbustl::ServerProxy::removeSignalHandler           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signalName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a signal handler previously registered with <a class="el" href="classdbustl_1_1ServerProxy.html#0ce3928d90c9332a0ef7fdd2fdb98362" title="Registers a handler to receive a DBUS signal : C++ functor version.">setSignalHandler()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signalName</em>&nbsp;</td><td>The name of the signal to remove handler to. If signal had no previously set handler, it succeeds anyway. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classdbustl_1_1DBusException.html" title="This class is used by DBusTL to report all of it internal errors.">DBusException</a></em>&nbsp;</td><td>if signalName is invalid. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>dbustl-1/ServerProxy<li>ServerProxy.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>DBus Template Library 0.3.0 documentation, generated by &nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
