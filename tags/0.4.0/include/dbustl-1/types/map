/*
 *  DBusTL - D-Bus Template Library
 *
 *  Copyright (C) 2008, 2009  Fabien Chevalier <chefabien@gmail.com>
 *  
 *
 *  This file is part of the DBus Template Library.
 *
 *  The DBus Template Library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  DBus Template Library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with DBus Template Library.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// STL map & multimap support

#ifndef DBUSTL_TYPES_MAP
#define DBUSTL_TYPES_MAP

#include <map>

#include <dbustl-1/types/StdTools>

namespace dbustl {
namespace types {

/* map & multimap shared support */
template <typename K, typename V>
struct Signature<std::pair<const K, V> > {
    static inline const char* value() {
        static const std::string signature = std::string(DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING) + 
            Signature<K>::value() +
            Signature<V>::value() +
            DBUS_DICT_ENTRY_END_CHAR_AS_STRING;
        return signature.c_str();
    }
};

/* map support */

template<typename K, typename V, typename X, typename Y>
struct Serializer<std::map<K, V, X, Y> > {
    static dbus_bool_t run(DBusMessageIter* it, const std::map<K, V, X, Y>& arg);
};
template<typename K, typename V, typename X, typename Y>
dbus_bool_t Serializer<std::map<K, V, X, Y> >::run(DBusMessageIter* it, const std::map<K, V, X, Y>& arg)
{
    typename std::map<K, V, X, Y>::const_iterator containerIter;
    DBusMessageIter arrayIterator;

    if(dbus_message_iter_open_container(it, DBUS_TYPE_ARRAY, 
        Signature<typename std::map<K, V, X, Y>::value_type>::value(), 
        &arrayIterator) == FALSE) {
        return FALSE;
    }
    
    for(containerIter = arg.begin(); containerIter != arg.end(); ++containerIter) {
        DBusMessageIter dictEntryIterator;
        if(dbus_message_iter_open_container(&arrayIterator, DBUS_TYPE_DICT_ENTRY, NULL, &dictEntryIterator) == FALSE) {
            return FALSE;
        }
        if(Serializer<K>::run(&dictEntryIterator, containerIter->first) == FALSE) return FALSE;
        if(Serializer<V>::run(&dictEntryIterator, containerIter->second) == FALSE) return FALSE;
        if(dbus_message_iter_close_container(&arrayIterator, &dictEntryIterator) == FALSE) return FALSE;
    }
    
    return dbus_message_iter_close_container(it, &arrayIterator);
}

template<typename K, typename V, typename X, typename Y>
struct Deserializer<std::map<K, V, X, Y> > {
    static dbus_bool_t run(DBusMessageIter* it, std::map<K, V, X, Y>* arg);
};
template<typename K, typename V, typename X, typename Y>
dbus_bool_t Deserializer<std::map<K, V, X, Y> >::run(DBusMessageIter* it, std::map<K, V, X, Y>* arg)
{
    DBusMessageIter arrayIterator;
    DBusMessageIter dictEntryIterator;
    if(dbus_message_iter_get_arg_type(it) != DBUS_TYPE_ARRAY) {
        return FALSE;
    }
    
    dbus_message_iter_recurse(it, &arrayIterator);
    while (dbus_message_iter_get_arg_type(&arrayIterator) == DBUS_TYPE_DICT_ENTRY) {
        dbus_message_iter_recurse(&arrayIterator, &dictEntryIterator);
        std::pair<K, V> v;
        
        if(Deserializer<K>::run(&dictEntryIterator, &v.first) == FALSE) {
            return FALSE;
        }
        
        std::pair<typename std::map<K, V, X, Y>::iterator, bool> ins = arg->insert(v);
        //Insert should always succeed, otherwiser other side has sent us crap
        //If not (which we have to deal with due to security issues), we bail out
        if(!ins.second) return FALSE;
        
        dbus_message_iter_next(&dictEntryIterator);
        if(Deserializer<V>::run(&dictEntryIterator, &(ins.first->second)) == FALSE) {
            return FALSE;
        }

        dbus_message_iter_next(&arrayIterator);
    }
    
    return TRUE;
}
    
/* multimap support */

template<typename K, typename V, typename X, typename Y>
struct Deserializer<std::multimap<K, V, X, Y> > {
    static dbus_bool_t run(DBusMessageIter* it, std::multimap<K, V, X, Y>* arg);
};
template<typename K, typename V, typename X, typename Y>
dbus_bool_t Deserializer<std::multimap<K, V, X, Y> >::run(DBusMessageIter* it, std::multimap<K, V, X, Y>* arg)
{
    DBusMessageIter arrayIterator;
    DBusMessageIter dictEntryIterator;
    if(dbus_message_iter_get_arg_type(it) != DBUS_TYPE_ARRAY) {
        return FALSE;
    }
    
    dbus_message_iter_recurse(it, &arrayIterator);
    while (dbus_message_iter_get_arg_type(&arrayIterator) == DBUS_TYPE_DICT_ENTRY) {
        dbus_message_iter_recurse(&arrayIterator, &dictEntryIterator);
        std::pair<K, V> v;
        
        if(Deserializer<K>::run(&dictEntryIterator, &v.first) == FALSE) {
            return FALSE;
        }
        
        typename std::multimap<K, V, X, Y>::iterator it = arg->insert(v);
        
        dbus_message_iter_next(&dictEntryIterator);
        if(Deserializer<V>::run(&dictEntryIterator, &(it->second)) == FALSE) {
            return FALSE;
        }

        dbus_message_iter_next(&arrayIterator);
    }
    
    return TRUE;
}

}
}

#endif /* DBUSTL_TYPES_MAP */
