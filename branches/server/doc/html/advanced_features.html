<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DBus Template Library: Advanced features</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="advanced_features">Advanced features </a></h1><h2><a class="anchor" name="datatypes">
More complex datatypes</a></h2>
DBusTL does its best not to enforce the used of any data type onto the user of: this makes it easier for DBusTL to fit with existing C++ toolkits that already have their own containers. This means DBusTL does not define new objects for the ARRAY, STRUCT, DICT, and VARIANT DBus data types.<p>
Currently DBusTL comes with builting support for the following STL containers.<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th>Container </th><th>Mapped dbus type </th><th>Can serialize ? </th><th>Can deserialize ?  </th></tr>
<tr>
<td>std::vector </td><td>ARRAY </td><td>yes </td><td>yes  </td></tr>
<tr>
<td>std::list </td><td>ARRAY </td><td>yes </td><td>yes  </td></tr>
<tr>
<td>std::set </td><td>ARRAY </td><td>yes </td><td>yes  </td></tr>
<tr>
<td>std::multiset </td><td>ARRAY </td><td>yes </td><td>yes  </td></tr>
<tr>
<td>std::map </td><td>DICT </td><td>yes </td><td>yes </td></tr>
<tr>
<td>std::multimap </td><td>DICT </td><td>no </td><td>yes  </td></tr>
</table>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>std::set: Duplicate array elements are merged during deserialization <p>
std::multimap: Serialization is not supported as there is no D-Bus container able to store the content of a multimap.</dd></dl>
So let's see how simple this is:<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;dbustl-1/dbustl&gt;</span>

<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>dbustl;
 
<span class="keywordtype">int</span> main()
{
    ObjectProxy remoteObject(Connection::sessionBus(), 
        <span class="stringliteral">"/PythonServerObject"</span>, <span class="stringliteral">"com.example.SampleService"</span>);
    <span class="keywordflow">try</span> {
        list&lt;int32_t&gt; in, out;
        in.push_back(1);
        in.push_back(2);
        in.push_back(3);
        remoteObject.call(<span class="stringliteral">"test_array_of_int"</span>, in, &amp;out); 

        <span class="keywordflow">if</span>(in == out)
            cout &lt;&lt; <span class="stringliteral">"Received a valid reply"</span> &lt;&lt; endl;
    }
    <span class="keywordflow">catch</span>(<span class="keyword">const</span> DBusException&amp; e) {
        <span class="comment">/* Dbus call failed: e.name() constains error cause */</span>
        cerr &lt;&lt; e.what() &lt;&lt; endl;
    } 
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
Support for those containers is generated "on the fly" using templates. This means that if Cont is a supported DBusTL container and T is a supported DBusTL type, then Cont&lt;T&gt; becomes a DBusTL supported type. This means that when recursivity comes into play Cont&lt;Cont&lt;T&gt; &gt; becomes a supported type too. Even more than that, you can mix supported containers of different kind, such as std::map&lt;std::string, std::list&lt;double&gt; &gt; for instance, which works perfectly fine. All is computed behind the scene for you.<p>
As you probably already have understood, DBusTL is designed to be extended to support data types other than STL ones. You can even extended to support your own custom program internal data structures as explained in the <a class="el" href="extending.html">Extending DBusTL to support custom data types</a> page.<h2><a class="anchor" name="async">
Asynchronous method calls</a></h2>
To be written. <h2><a class="anchor" name="signals">
Working with signals.</a></h2>
To be written. <h2><a class="anchor" name="exceptions">
C++ exceptions support</a></h2>
It is possible to use DBusTL with or without C++ exceptions: the main advantage is that without exceptions support, code generated by DBusTL template instanciation is typically 30-40% smaller, which can be nice for embedded systems.<p>
DBusTL ships with two version of each library. For instance there is a library called dbustl, and a one called dbustl-noex. dbustl-noex stands for "no exceptions". This version of the library is built with C++ exceptions support disabled (-fno-exceptions gcc option). You should use this version if you don't use exceptions in your main program.<p>
To used dbustl without exceptions, and benefit from a smaller generated code size, you should:<ol type=1>
<li>Use version xxxxx-noex instead of xxxxx of DBusTL libraries.</li><li>Add DBUSTL_NO_EXCEPTIONS compilation flag to your program</li><li>Add -fno-exceptions option on gcc command line.</li></ol>
<p>
If your program used pkg-config, the the last two steps are not needed as all is handled for you behind the scene. </div>
<hr size="1"><address style="text-align: right;"><small>D-Bus Template Library 0.4.0-pre documentation, generated by &nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
